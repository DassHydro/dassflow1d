!======================================================================================================================!
!
!                    DassFlow Version 2.0
!
!======================================================================================================================!
!
!  Copyright University of Toulouse-INSA - CNRS (France)
!
!  This file is part of the DassFlow software (Data Assimilation for Free Surface Flows).
!  DassFlow is a computational software aiming at simulating geophysical free surface flows.
!  It is designed for Variational Data Assimilation (4D-var) and sensitivity analyses. 
! Inverse capabilities are based on the adjoint code which is generated by 
! a source-to-source algorithmic differentiation (Tapenade software used).
!
!  DassFlow software includes few mostly independent "modules" with common architectures and structures:
!    - DassFlow 2DShallow (shallow water equations in (h,q), finite volumes), i.e. the present code.
!    - DassFlow3D  (non-linear Stokes equations, finite elements, mobile geometries, ALE).
!    - DassFlow 1D (shallow water equations in (S,Q), finite volumes or finite differences), river hydraulics.
!  Please consult the DassFlow webpage for more details: http://www.math.univ-toulouse.fr/DassFlow
!
! You have used DassFlow in an article, a scientific document etc ?  How to cite us ? Please consult the webpage.
! 
!  Many people have contributed to the DassFlow developments from the initial version to the latest ones.
!  Current main developers or scientific contributers are:
!               P. Brisset (CNES & Mathematics Institute of Toulouse & INSA Toulouse)
!               F. Couderc (CNRS & Mathematics Institute of Toulouse IMT)
!               P.-A. Garambois (INSA & ICUBE Strasbourg)
!               J. Monnier (INSA & Mathematics Institute of Toulouse IMT).
!               J.-P. Vila (INSA & Mathematics Institute of Toulouse IMT).
!  and former other developers (R. Madec, M. Honnorat and J. Marin).
!
!  Scientific contact : jerome.monnier@insa-toulouse.fr
!  Technical  contacts : frederic.couderc@math.univ-toulouse.fr, pierre.brisset@insa-toulouse.fr
!
!  This software is governed by the CeCILL license under French law and abiding by the rules of distribution
!  of free software. You can use, modify and/or redistribute the software under the terms of the CeCILL license
!  as circulated by CEA, CNRS and INRIA at the following URL: "http://www.cecill.info".
!
!  As a counterpart to the access to the source code and rights to copy, modify and redistribute granted by the
!  license, users are provided only with a limited warranty and the software's author, the holder of the economic
!  rights, and the successive licensors have only limited liability.
!
!  In this respect, the user's attention is drawn to the risks associated with loading, using, modifying and/or
!  developing or reproducing the software by the user in light of its specific status of free software, that may
!  mean that it is complicated to manipulate, and that also therefore means that it is reserved for developers and
!  experienced professionals having in-depth computer knowledge. Users are therefore encouraged to load and test the
!  software's suitability as regards their requirements in conditions enabling the security of their systems and/or
!  data to be ensured and, more generally, to use and operate it in the same conditions as regards security.
!
!  The fact that you are presently reading this means that you have had knowledge of the CeCILL license and that you
!  accept its terms.
!
!======================================================================================================================!
!> \file preissmann_LPI.f90
!! \brief This file includes the computation with Preissmann method with LPI with classical resolution. An unique subroutine :
!! preissmann

!> Subroutine of the computation with Preissmann method with LPI with classical resolution.  
!!
!! \details Algorithm used:
!!
!!     Update boundaries conditions
!!     Update mvector
!!     Update of S,Q,H
!!     Write the matrix A and Y with LPI term
!!     Solve AX=Y with mumps
!!     Get new S,Q
!!
!! \param[in]  dof Unknowns of the model.
!! \param[in]    msh Mesh of the model.


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Perform Preissmann with LPI to Shallow-Water Equations
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!


#ifdef DEBLOCK
SUBROUTINE preissmann_LPI( dof , msh )

   USE m_common
   USE m_mesh
   USE m_time_screen          !NOADJ
   USE m_model
   USE m_linear_solver        !NOADJ
   USE m_user_data
   USE m_numeric
   implicit none

!======================================================================================================================!
!  Interface Variables
!======================================================================================================================!

   TYPE(Mesh), intent(in   )  ::  msh
   TYPE( unk ), intent(inout)  ::  dof

!======================================================================================================================!
!  Local Variables
!======================================================================================================================!

   real(rp) :: sigma          ! Value of sigma in the preissmann scheme

   ! Definition C coefficients
   real(rp) :: Cb1,Cb2,Cb3          ! Coefficient Cb1,Cb2,Cb3
   real(rp) :: Cc1,Cc4,Cc5          ! Coefficient Cc1,Cc4,Cc5
   real(rp) :: Cd1,Cd4,Cd5          ! Coefficient Cd1,Cd4,Cd5
   real(rp) :: Ce2,Ce3              ! Coefficient Ce2,Ce3
   real(rp) :: Cf1,Cf2,Cf3,Cf4,Cf5  ! Coefficient Cf1,Cf2,Cf3,Cf4,Cf5
   real(rp) :: Cg,Ch,Ci,Cj,Ck       ! Coefficient Cg,Ch,Ci,Cj,Ck
   real(rp) :: Ch1,Ch4,Ch5          ! Coefficient Ch1,Ch4,Ch5
   real(rp) :: Cl,Cm,Cn,Co,Cp       ! Coefficient Cl,Cm,Cn,Co,Cp  


   ! Useful computation
   real(rp) :: dx,dpdx             ! Spatial step size and inverse of spatial step size
   
   ! Physical parameters
   real(rp), dimension(msh%ncs+4) :: q         ! Discharge
   real(rp), dimension(msh%ncs+4) :: z         ! Water elevation
   real(rp), dimension(msh%ncs+4) :: w         ! Water surface width 
   real(rp), dimension(msh%ncs+4) :: perimeter ! Wet Perimeter 
   real(rp), dimension(msh%ncs+4) :: rh        ! Hydraulic radius
   real(rp), dimension(msh%ncs+4) :: v         ! Velocity flow
   real(rp), dimension(msh%ncs+4) :: Manning   ! Manning
   real(rp), dimension(msh%ncs+4) :: debitance ! Debitance
   real(rp), dimension(msh%ncs+4) :: zp1       ! New Water elevation
   real(rp), dimension(msh%ncs+4) :: qp1
   real(rp) :: val0, val,conlim,dcldval,frp

   !Function
   real(rp)  :: PerimeterFromH,coeff,coeff1,coeff2,fr,a,b
   real(rp)  :: GetWFromH,HtoS

   real(rp)  :: frlpi=1_rp
   real(rp)  :: mlpi=10.0_rp

   integer(ip ) :: n,jl

   call calc_boundary_state( msh,dof)

   !======================================================================================================================!
   !  Update of data
   !======================================================================================================================!
   do ie=1,msh%ncs+4
      q(ie)         = dof%q(ie)                             ! Update of q
      z(ie)         = dof%h(ie)+bathy_cell(ie)              ! Update of water elevation
      dof%s(ie)     = HtoS(msh,ie,dof%h(ie))               ! Update of wet surface
      w(ie)         = GetWFromH(msh,dof%h(ie),ie)          ! Update of water surface width 
      perimeter(ie) = PerimeterFromH(msh,dof%h(ie),ie)     ! Update of Wet Perimeter 
      rh(ie)        = dof%s(ie)/perimeter(ie)               ! Update of Hydraulic radius
      v(ie)         = dof%q(ie)/dof%s(ie)                   ! Update of speed flow
   end do
   call calc_K_everywhere(dof, Manning, ie)                      ! Update of Manning
   do ie=1,msh%ncs+4
      debitance(ie) = Manning(ie)*dof%s(ie)*(rh(ie)**(d2p3))  ! Update of debitance
   end do
   
   perimeter(1)=perimeter(3)
   perimeter(2)=perimeter(3)

   perimeter(msh%ncs+3)=perimeter(msh%ncs+2)
   perimeter(msh%ncs+4)=perimeter(msh%ncs+2)

   z(1)=bathy_cell(1)+dof%h(3)
   z(2)=bathy_cell(2)+dof%h(3)

   !z(msh%ncs+3)=bathy_cell(msh%ncs+3)+dof%h(msh%ncs+2)
   !z(msh%ncs+4)=bathy_cell(msh%ncs+4)+dof%h(msh%ncs+2)

   ! K.Larnier -> Code 0.55 Thesis 2./3
   ! H.Roux    -> Code 2./3 Thesis 0.55
   sigma= 0.55_rp !(2.0_rp/3.0_rp) 


   n=msh%ncs
   mumps_par%A    (1) = 1._rp
   mumps_par%rhs  (1) = q(2)  ! Inflow 

   Cg=sigma !
   Ci=sigma !

   do ie=3,msh%ncs+1

      !Froude computation
      fr=abs(v(ie)/sqrt(g*dof%h(ie)))
      frp=abs(v(ie+1)/sqrt(g*dof%h(ie+1)))

      ! Computation of LPI coefficient at point ie
      if (fr.lt.frlpi) then
         coeff1=1.0_rp-(fr/frlpi)**mlpi
      else
         coeff1=0.0_rp
      endif


      !Ce
      Ce2   = coeff1/(2._rp*dt)
      Ce3   = coeff1/(2._rp*dt)


      ! Computation of LPI coefficient at point ie and ie+1
      if (frp.lt.frlpi) then
         coeff2=1.0_rp-(frp/frlpi)**mlpi
      else
         coeff2=0.0_rp
      endif

      if (coeff2.lt.coeff1) then
         coeff=coeff2
      else
         coeff=coeff1
      endif

      dx    = msh%cs(ie+1)%deltademi
      dpdx  = (1._rp)/dx
      Ch    =  (dx/(4._rp*dt))*(w(ie+1)+w(ie)) 
      Cj    = -(dx/(4._rp*dt))*(w(ie+1)+w(ie))                            
      Ck    = -(q(ie+1)-q(ie))    


! Larnier
!      if(Q(ie+1).le.0.0_rp) then 
!         temp1= Q(ie+1)
!      else 
!         temp1=-Q(ie+1)
!      end if
!      if(Q(ie  ).le.0.0_rp) then 
!         temp2= Q(ie)
!      else 
!         temp2=-Q(ie)
!      end if
!      Cb1   = demi*(Q(ie+1)*abs(Q(ie+1))+Q(ie)*abs(Q(ie))) 
!      Cb2   = sigma*temp1
!      Cb3   = sigma*temp2

! Thesis and code H.roux
      !Cb1   = demi*(Q(ie+1)*abs(Q(ie+1))+Q(ie)*abs(Q(ie)))
      !Cb2   = sigma*(Q(ie+1))                      
      !Cb3   = sigma*(Q(ie))  
  
! LIDO
      Cb1   = demi*(Q(ie+1)*abs(Q(ie+1))+Q(ie)*abs(Q(ie))) 
      Cb2   = sigma*abs(Q(ie+1))                      
      Cb3   = sigma*abs(Q(ie))                        
      
      !CC
      Cc1   = demi*(debitance(ie+1)*debitance(ie+1)+debitance(ie)*debitance(ie)) 

      if (z(ie+1).ne.z(ie)) then
         Cc4   = sigma*debitance(ie+1)*d1p3*(Manning(ie+1)*Rh(ie+1)**d2p3)*(5._rp*w(ie+1)-2._rp*Rh(ie+1)*&
         ((perimeter(ie+1)-perimeter(ie  ))/(z(ie+1)-z(ie  ))))
      else 
         Cc4   = sigma*debitance(ie+1)*d1p3*(Manning(ie+1)*Rh(ie+1)**d2p3)*(5._rp*w(ie+1))
      end if

      if (z(ie).ne.z(ie-1)) then
         Cc5   = sigma*debitance(ie  )*d1p3*(Manning(ie  )*Rh(ie  )**d2p3)*(5._rp*w(ie  )-2._rp*Rh(ie  )*&
         ((perimeter(ie)-perimeter(ie-1))/(z(ie)-z(ie-1))))
      else 
         Cc5   = sigma*debitance(ie  )*d1p3*(Manning(ie  )*Rh(ie  )**d2p3)*(5._rp*w(ie  ))
      end if

      !CD
      Cd1   = dpdx*(z(ie+1)-z(ie))
      Cd4   =  sigma*dpdx
      Cd5   = -sigma*dpdx

      !CF
      Cf1   =  coeff*dpdx*(q(ie+1)*v(ie+1)-q(ie)*v(ie))
      Cf2   =  coeff*dpdx*2._rp*sigma*v(ie+1)
      Cf3   = -coeff*dpdx*2._rp*sigma*v(ie  )
      Cf4   = -coeff*dpdx*sigma*v(ie+1)*v(ie+1)*w(ie+1)
      Cf5   =  coeff*dpdx*sigma*v(ie  )*v(ie  )*w(ie  )

      !CH
      Ch1   = (1._rp/(2._rp*g))*((1._rp/dof%s(ie+1))+(1._rp/dof%s(ie)))
      Ch4   = - demi*((w(ie+1)*sigma)/(g*dof%s(ie+1)*dof%s(ie+1))) 
      Ch5   = - demi*((w(ie  )*sigma)/(g*dof%s(ie  )*dof%s(ie  )))

      !
      Cl    = Cb2+Cc1*Ch1*(Ce2+Cf2)
      Cm    = Cc4*(Cd1+Ch1*Cf1)+Cc1*(Cd4+Ch1*Cf4+Ch4*Cf1)
      Cn    = -(Cb3+CC1*CH1*(Ce3+Cf3))
      Co    = -(Cc5*(Cd1+Ch1*Cf1)+Cc1*(Cd5+Ch1*Cf5+Ch5*Cf1))
      Cp    = -(Cb1+Cc1*(Cd1+Ch1*Cf1))

      
      jl=ie-2
      mumps_par%A    (jl*8-6) = CG
      mumps_par%A    (jl*8-5) = CH
      mumps_par%A    (jl*8-4) =-CI
      mumps_par%A    (jl*8-3) =-CJ
      mumps_par%rhs  (2*jl)   = CG*Q(ie+1)+CH*Z(ie+1)-CI*Q(ie)-CJ*Z(ie)+CK


      mumps_par%A    (jl*8-2) = CL
      mumps_par%A    (jl*8-1) = CM
      mumps_par%A    (jl*8  ) =-CN
      mumps_par%A    (jl*8+1) =-CO
      mumps_par%rhs  (2*jl+1) = CL*Q(ie+1)+CM*Z(ie+1)-CN*Q(ie)-CO*Z(ie)+CP
   end do

   !===================================================================================================================!
   !  Computing of Q^{n+1}_{N} and H^{n+1}_{N}
   !===================================================================================================================!
   mumps_par%rhs(2*n)      = z(msh%ncs+3)+bathy_cell(msh%ncs+2)-bathy_cell(msh%ncs+3)


   mumps_par%A((n-1)*8+2)  = 1._rp

   mumps_par%JOB=6
   mumps_par%ICNTL(3)=0
   call DMUMPS( mumps_par )

   do ie=3,msh%ncs+2
      jl=ie-2
      zp1   (ie) = mumps_par%rhs(jl*2)
      qp1   (ie) = mumps_par%rhs(jl*2-1)
      dof%q (ie) = mumps_par%rhs(jl*2-1)
      dof%h (ie) = zp1(ie)-bathy_cell(ie)
      dof%s (ie) = HtoS( msh,ie, dof%h(ie) ) 
   end do


END SUBROUTINE preissmann_LPI

#endif