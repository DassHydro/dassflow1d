!======================================================================================================================!
!
!                    DassFlow Version 2.0
!
!======================================================================================================================!
!
!  Copyright University of Toulouse-INSA - CNRS (France)
!
!  This file is part of the DassFlow software (Data Assimilation for Free Surface Flows).
!  DassFlow is a computational software aiming at simulating geophysical free surface flows.
!  It is designed for Variational Data Assimilation (4D-var) and sensitivity analyses. 
! Inverse capabilities are based on the adjoint code which is generated by 
! a source-to-source algorithmic differentiation (Tapenade software used).
!
!  DassFlow software includes few mostly independent "modules" with common architectures and structures:
!    - DassFlow 2DShallow (shallow water equations in (h,q), finite volumes), i.e. the present code.
!    - DassFlow3D  (non-linear Stokes equations, finite elements, mobile geometries, ALE).
!    - DassFlow 1D (shallow water equations in (S,Q), finite volumes or finite differences), river hydraulics.
!  Please consult the DassFlow webpage for more details: http://www.math.univ-toulouse.fr/DassFlow
!
! You have used DassFlow in an article, a scientific document etc ?  How to cite us ? Please consult the webpage.
! 
!  Many people have contributed to the DassFlow developments from the initial version to the latest ones.
!  Current main developers or scientific contributers are:
!               P. Brisset (CNES & Mathematics Institute of Toulouse & INSA Toulouse)
!               F. Couderc (CNRS & Mathematics Institute of Toulouse IMT)
!               P.-A. Garambois (INSA & ICUBE Strasbourg)
!               J. Monnier (INSA & Mathematics Institute of Toulouse IMT).
!               J.-P. Vila (INSA & Mathematics Institute of Toulouse IMT).
!  and former other developers (R. Madec, M. Honnorat and J. Marin).
!
!  Scientific contact : jerome.monnier@insa-toulouse.fr
!  Technical  contacts : frederic.couderc@math.univ-toulouse.fr, pierre.brisset@insa-toulouse.fr
!
!  This software is governed by the CeCILL license under French law and abiding by the rules of distribution
!  of free software. You can use, modify and/or redistribute the software under the terms of the CeCILL license
!  as circulated by CEA, CNRS and INRIA at the following URL: "http://www.cecill.info".
!
!  As a counterpart to the access to the source code and rights to copy, modify and redistribute granted by the
!  license, users are provided only with a limited warranty and the software's author, the holder of the economic
!  rights, and the successive licensors have only limited liability.
!
!  In this respect, the user's attention is drawn to the risks associated with loading, using, modifying and/or
!  developing or reproducing the software by the user in light of its specific status of free software, that may
!  mean that it is complicated to manipulate, and that also therefore means that it is reserved for developers and
!  experienced professionals having in-depth computer knowledge. Users are therefore encouraged to load and test the
!  software's suitability as regards their requirements in conditions enabling the security of their systems and/or
!  data to be ensured and, more generally, to use and operate it in the same conditions as regards security.
!
!  The fact that you are presently reading this means that you have had knowledge of the CeCILL license and that you
!  accept its terms.
!
!======================================================================================================================!
!> \file rk_time_step.f90
!! \brief This file includes only rk_time_step (for more detail see rk_time_step routine).


!> Time integregation of the scheme.
!!
!! \details This subroutine done the time integration of scheme. Euler integration (rk2) to have order 2 with MUSCL.
!!
!! \param[inout]  dof  Unknowns of the model.
!! \param[in]  msh Mesh of the model.
SUBROUTINE rk_time_step( dof , msh )

   USE m_common
   USE m_mesh
   USE m_time_screen!NOADJ
   USE m_model

   implicit none

!======================================================================================================================!
!  Interface Variables
!======================================================================================================================!

   TYPE(Mesh), intent(in   )  ::  msh
   TYPE( unk ), intent(inout)  ::  dof

!======================================================================================================================!
!  Local Variables
!======================================================================================================================!

   
   real(rp), dimension(msh%ncs+4) :: h_temp 
   real(rp), dimension(msh%ncs+4) :: q_temp 
   real(rp), dimension(msh%ncs+4) :: s_temp,u,u_temp,u_temp2


!======================================================================================================================!
!  Begin Subroutine
!======================================================================================================================!

   h_temp( 1 : msh%ncs+4 )  =  dof%h( 1 : msh%ncs+4 )
   s_temp( 1 : msh%ncs+4 )  =  dof%s( 1 : msh%ncs+4 )
   q_temp( 1 : msh%ncs+4 )  =  dof%q( 1 : msh%ncs+4 )

   u_temp( 1 : msh%ncs+4 )  =  dof%q( 1 : msh%ncs+4 )/dof%s( 1 : msh%ncs+4 )
   select case( spatial_scheme )
      
      case('rk2_b1')!NOADJ
         call euler_time_step_first_b1( dof , msh )!NOADJ
         call euler_time_step_first_b1( dof , msh )!NOADJ

      case('rk2_b2')!NOADJ
         call euler_time_step_first_b2( dof , msh )!NOADJ
         call euler_time_step_first_b2( dof , msh )!NOADJ

      case('rk2_implicit_low_froude')!NOADJ
         call implicit_low_froude( dof , msh )     !NOADJ           
         call implicit_low_froude( dof , msh )     !NOADJ           

      case('rk2_explicit_low_froude_b1')!NOADJ
         call explicit_low_froude_b1( dof , msh )!NOADJ  
         call explicit_low_froude_b1( dof , msh )!NOADJ  

      case('rk2_explicit_low_froude_b2')  
         call explicit_low_froude_b2( dof , msh ) 
         call explicit_low_froude_b2( dof , msh )  

      case default!NOADJ
         call euler_time_step_first( dof , msh )!NOADJ
         call euler_time_step_first( dof , msh )!NOADJ  

   end select


   dof%h( 1 : msh%ncs+4 )  =  0.5_rp * ( h_temp( 1 : msh%ncs+4 ) + dof%h( 1 : msh%ncs+4 ) )
   dof%s( 1 : msh%ncs+4 )  =  0.5_rp * ( s_temp( 1 : msh%ncs+4 ) + dof%s( 1 : msh%ncs+4 ) )
   dof%q( 1 : msh%ncs+4 )  =  0.5_rp * ( q_temp( 1 : msh%ncs+4 ) + dof%q( 1 : msh%ncs+4 ) )

   return

END SUBROUTINE rk_time_step
