!======================================================================================================================!
!
!                    DassFlow Version 2.0
!
!======================================================================================================================!
!
!  Copyright University of Toulouse-INSA - CNRS (France)
!
!  This file is part of the DassFlow software (Data Assimilation for Free Surface Flows).
!  DassFlow is a computational software aiming at simulating geophysical free surface flows.
!  It is designed for Variational Data Assimilation (4D-var) and sensitivity analyses. 
! Inverse capabilities are based on the adjoint code which is generated by 
! a source-to-source algorithmic differentiation (Tapenade software used).
!
!  DassFlow software includes few mostly independent "modules" with common architectures and structures:
!    - DassFlow 2DShallow (shallow water equations in (h,q), finite volumes), i.e. the present code.
!    - DassFlow3D  (non-linear Stokes equations, finite elements, mobile geometries, ALE).
!    - DassFlow 1D (shallow water equations in (S,Q), finite volumes or finite differences), river hydraulics.
!  Please consult the DassFlow webpage for more details: http://www.math.univ-toulouse.fr/DassFlow
!
! You have used DassFlow in an article, a scientific document etc ?  How to cite us ? Please consult the webpage.
! 
!  Many people have contributed to the DassFlow developments from the initial version to the latest ones.
!  Current main developers or scientific contributers are:
!               K. Larnier (CS & Mathematics Institute of Toulouse & INSA Toulouse)
!               P. Brisset (CNES & Mathematics Institute of Toulouse & INSA Toulouse)
!               F. Couderc (CNRS & Mathematics Institute of Toulouse IMT)
!               P.-A. Garambois (INSA & ICUBE Strasbourg)
!               J. Monnier (INSA & Mathematics Institute of Toulouse IMT).
!               J.-P. Vila (INSA & Mathematics Institute of Toulouse IMT).
!  and former other developers (R. Madec, M. Honnorat and J. Marin).
!
!  Scientific contact : jerome.monnier@insa-toulouse.fr
!  Technical  contacts : frederic.couderc@math.univ-toulouse.fr, pierre.brisset@insa-toulouse.fr, kevin.larnier@c-s.fr
!
!  This software is governed by the CeCILL license under French law and abiding by the rules of distribution
!  of free software. You can use, modify and/or redistribute the software under the terms of the CeCILL license
!  as circulated by CEA, CNRS and INRIA at the following URL: "http://www.cecill.info".
!
!  As a counterpart to the access to the source code and rights to copy, modify and redistribute granted by the
!  license, users are provided only with a limited warranty and the software's author, the holder of the economic
!  rights, and the successive licensors have only limited liability.
!
!  In this respect, the user's attention is drawn to the risks associated with loading, using, modifying and/or
!  developing or reproducing the software by the user in light of its specific status of free software, that may
!  mean that it is complicated to manipulate, and that also therefore means that it is reserved for developers and
!  experienced professionals having in-depth computer knowledge. Users are therefore encouraged to load and test the
!  software's suitability as regards their requirements in conditions enabling the security of their systems and/or
!  data to be ensured and, more generally, to use and operate it in the same conditions as regards security.
!
!  The fact that you are presently reading this means that you have had knowledge of the CeCILL license and that you
!  accept its terms.
!
!======================================================================================================================!
!> \file preissmann_double_sweep.f90
!! \brief This file includes the computation with Preissmann method without LPI with double sweep resolution. An unique subroutine :
!! preissmann

!> Subroutine of the computation with Preissmann method without LPI with double sweep resolution.
!!
!! \details Algorithm used:
!!
!!     Update boundaries conditions
!!     Update mvector
!!     Update of S,Q,H
!!     Write coefficient for the double sweep
!!     Double sweep
!!     Get new S,Q
!!
!! For more details on the double sweep resolution see documentation.
!! \param[in]  dof Unknowns of the model.
!! \param[in]    msh Mesh of the model.


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Solve Shallow-Water Equations using Preissman+LPI scheme
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!


#ifdef DEBLOCK
SUBROUTINE preissmann_double_sweep( dof , msh )

   USE m_common
   USE m_mesh
   USE m_time_screen          !NOADJ
   USE m_model
   USE m_linear_solver        !NOADJ
   USE m_user_data
   USE m_numeric
   implicit none

!======================================================================================================================!
!  Interface Variables
!======================================================================================================================!

   TYPE(Mesh), intent(in   )  ::  msh
   TYPE( unk ), intent(inout)  ::  dof

!======================================================================================================================!
!  Local Variables
!======================================================================================================================!

   real(rp) :: sigma          ! Value of sigma in the preissmann scheme

   ! Definition C coefficients
   real(rp) :: Cb1,Cb2,Cb3          ! Coefficient Cb1,Cb2,Cb3
   real(rp) :: Cc1,Cc4,Cc5          ! Coefficient Cc1,Cc4,Cc5
   real(rp) :: Cd1,Cd4,Cd5          ! Coefficient Cd1,Cd4,Cd5
   real(rp) :: Ce2,Ce3              ! Coefficient Ce2,Ce3
   real(rp) :: Cf1,Cf2,Cf3,Cf4,Cf5  ! Coefficient Cf1,Cf2,Cf3,Cf4,Cf5
   real(rp) :: Cg,Ch,Ci,Cj,Ck       ! Coefficient Cg,Ch,Ci,Cj,Ck
   real(rp) :: Ch1,Ch4,Ch5          ! Coefficient Ch1,Ch4,Ch5
   real(rp) :: Cl,Cm,Cn,Co,Cp       ! Coefficient Cl,Cm,Cn,Co,Cp  
   real(rp), dimension(msh%ncs+4) :: cr,cs,ct ! Coefficient Cr, Cs, Ct
   
   ! Definition of G coefficients
   real(rp), dimension(msh%ncs+4) :: Gaj,Gbj,Gcj ! Coefficient Gaj,Gbj,Gcj 
   real(rp), dimension(msh%ncs+4) :: Gdj,Gej,Gfj ! Coefficient Gdj,Gej,Gfj 

   ! Useful computation
   real(rp) :: dx,dpdx             ! Spatial step size and inverse of spatial step size
   
   ! Physical parameters
   real(rp), dimension(msh%ncs+4) :: q         ! Discharge
   real(rp), dimension(msh%ncs+4) :: z         ! Water elevation
   real(rp), dimension(msh%ncs+4) :: w         ! Water surface width 
   real(rp), dimension(msh%ncs+4) :: perimeter ! Wet Perimeter 
   real(rp), dimension(msh%ncs+4) :: rh        ! Hydraulic radius
   real(rp), dimension(msh%ncs+4) :: v         ! Velocity flow
   real(rp), dimension(msh%ncs+4) :: Manning   ! Manning
   real(rp), dimension(msh%ncs+4) :: debitance ! Debitance
   real(rp), dimension(msh%ncs+4) :: zp1       ! New Water elevation
  
   real(rp) :: val0, val,conlim,dcldval

   !Function
   real(rp)  :: PerimeterFromH
   real(rp)  :: GetWFromH,HtoS

   real(rp)  :: zaval,qaval,temp,temp1


   real(rp)  :: frlpi=1_rp
   real(rp)  :: mlpi=10.0_rp

   !======================================================================================================================!
   !  Update of data
   !======================================================================================================================!
   
   do ie=1,msh%ncs+4
      q(ie)         = dof%q(ie)                             ! Update of q
      z(ie)         = dof%h(ie)+bathy_cell(ie)              ! Update of water elevation
      dof%s(ie)     = HtoS(msh,ie,dof%h(ie))               ! Update of wet surface
      w(ie)         = GetWFromH(msh,dof%h(ie),ie)          ! Update of water surface width 
      perimeter(ie) = PerimeterFromH(msh,dof%h(ie),ie)     ! Update of Wet Perimeter 
      rh(ie)        = dof%s(ie)/perimeter(ie)               ! Update of Hydraulic radius
      v(ie)         = dof%q(ie)/dof%s(ie)                   ! Update of speed flow
   end do
   call calc_K_everywhere(dof, Manning, ie)                      ! Update of Manning
   do ie=1,msh%ncs+4
      debitance(ie) = Manning(ie)*dof%s(ie)*(rh(ie)**(d2p3))  ! Update of debitance
   end do
   
   perimeter(1)=perimeter(3)
   perimeter(2)=perimeter(3)

   perimeter(msh%ncs+3)=perimeter(msh%ncs+2)
   perimeter(msh%ncs+4)=perimeter(msh%ncs+2)

   z(1)=bathy_cell(1)+dof%h(3)
   z(2)=bathy_cell(2)+dof%h(3)

   z(msh%ncs+3)=bathy_cell(msh%ncs+3)+dof%h(msh%ncs+2)
   z(msh%ncs+4)=bathy_cell(msh%ncs+4)+dof%h(msh%ncs+2)

   ! K.Larnier -> Code 0.55 Thesis 2./3
   ! H.Roux    -> Code 2./3 Thesis 0.55
   sigma= 0.55_rp !(2.0_rp/3.0_rp) 

   call calc_boundary_state( msh,dof)
   
   !======================================================================================================================!
   !  Cr0,Cs0,Ct0 computing
   !======================================================================================================================!
   Cr(3)=1._rp
   Cs(3)=0._rp
   
   !Ct(3)=-dof%q(3)+linear_interp( bc%hyd%t ,bc%hyd%q ,tc)
   Ct(3)=-dof%q(3)+ dof%q(2) 

   !======================================================================================================================!
   !  Ga,Gb,Gc,Gd,Gd,Ge,Gf computing and Cr,Cs,Ct computing
   !======================================================================================================================!

   Cg=sigma ! CG
   Ci=sigma ! CI

   do ie=3,msh%ncs+1
      !Ce
      Ce2   = (1._rp)/(2._rp*dt)
      Ce3   = (1._rp)/(2._rp*dt)

      dx    = msh%cs(ie+1)%deltademi
      dpdx = (1._rp)/dx
      Ch    =  (dx/(4._rp*dt))*(w(ie+1)+w(ie)) 
      Cj    = -(dx/(4._rp*dt))*(w(ie+1)+w(ie))                            
      Ck    = -(q(ie+1)-q(ie))       

      !CB
      Cb1   = demi*(Q(ie+1)*abs(Q(ie+1))+Q(ie)*abs(Q(ie))) 
      Cb2   = sigma*abs(Q(ie+1))                      
      Cb3   = sigma*abs(Q(ie))                                
      
      !CC
      Cc1   = demi*(debitance(ie+1)*debitance(ie+1)+debitance(ie)*debitance(ie)) 

      if (z(ie+1).ne.z(ie)) then
         Cc4   = sigma*debitance(ie+1)*d1p3*(Manning(ie+1)*Rh(ie+1)**d2p3)*(5._rp*w(ie+1)-2._rp*Rh(ie+1)*&
         ((perimeter(ie+1)-perimeter(ie  ))/(z(ie+1)-z(ie  ))))
      else 
         Cc4   = sigma*debitance(ie+1)*d1p3*(Manning(ie+1)*Rh(ie+1)**d2p3)*(5._rp*w(ie+1))
      end if

      if (z(ie).ne.z(ie-1)) then
         Cc5   = sigma*debitance(ie  )*d1p3*(Manning(ie  )*Rh(ie  )**d2p3)*(5._rp*w(ie  )-2._rp*Rh(ie  )*&
         ((perimeter(ie)-perimeter(ie-1))/(z(ie)-z(ie-1))))
      else 
         Cc5   = sigma*debitance(ie  )*d1p3*(Manning(ie  )*Rh(ie  )**d2p3)*(5._rp*w(ie  ))
      end if

      !CD
      Cd1   = dpdx*(z(ie+1)-z(ie))
      Cd4   =  sigma*dpdx
      Cd5   = -sigma*dpdx

      !CF
      Cf1   =  dpdx*(q(ie+1)*v(ie+1)-q(ie)*v(ie))
      Cf2   =  dpdx*2._rp*sigma*v(ie+1)
      Cf3   = -dpdx*2._rp*sigma*v(ie  )
      Cf4   = -dpdx*sigma*v(ie+1)*v(ie+1)*w(ie+1)
      Cf5   =  dpdx*sigma*v(ie  )*v(ie  )*w(ie  )

      !CH
      Ch1   = (1._rp/(2._rp*g))*((1._rp/dof%s(ie+1))+(1._rp/dof%s(ie)))
      Ch4   = - demi*((w(ie+1)*sigma)/(g*dof%s(ie+1)*dof%s(ie+1))) !(w(ie+1)/(dof%s(ie+1)*dof%s(ie+1)))
      Ch5   = - demi*((w(ie  )*sigma)/(g*dof%s(ie  )*dof%s(ie  )))

      !CL, CM, CN, CO, CP
      Cl    = Cb2+Cc1*Ch1*(Ce2+Cf2)
      Cm    = Cc4*(Cd1+Ch1*Cf1)+Cc1*(Cd4+Ch1*Cf4+Ch4*Cf1)
      Cn    = -(Cb3+CC1*CH1*(Ce3+Cf3))
      Co    = -(Cc5*(Cd1+Ch1*Cf1)+Cc1*(Cd5+Ch1*Cf5+Ch5*Cf1))
      Cp    = -(Cb1+Cc1*(Cd1+Ch1*Cf1))

      !Gaj, Gbj, Gc, Gdj, Gej, Gfj
      Gaj(ie)= ( Cl*Cj-Co*Cg)/(Cn*Cj-Co*Ci)
      Gbj(ie)= ( Cm*Cj-Co*Ch)/(Cn*CJ-Co*Ci)
      Gcj(ie)= (-Cp*Cj+Co*Ck)/(Cn*CJ-Co*Ci)
      Gdj(ie)= ( Cl*Ci-Cn*Cg)/(Co*Ci-Cn*Cj)
      Gej(ie)= ( Cm*Ci-Cn*Ch)/(Co*Ci-Cn*Cj)
      Gfj(ie)= (-Cp*Ci+Cn*Ck)/(Co*Ci-Cn*Cj)

      !Cr, Cs and Ct coefficients computing
      Cr(ie+1) = cr(ie)*Gaj(ie)+Cs(ie)*Gdj(ie)
      Cs(ie+1) = cr(ie)*Gbj(ie)+Cs(ie)*Gej(ie)
      Ct(ie+1) = ct(ie)-(Cr(ie)*Gcj(ie)+Cs(ie)*Gfj(ie))

   end do


   !===================================================================================================================!
   !  Computing of Q^{n+1}_{N} and H^{n+1}_{N}
   !===================================================================================================================!

   !Newton
   ie=msh%ncs+2
   val0=q(ie)
   qaval=dof%q(ie)
   zaval=z    (ie)
   val =val0+1.0_rp

   temp=1._rp
   temp1=0.000001
   do while (temp> temp1)! zerom)
      conlim=cr(msh%ncs+2)*(val0-dof%q(msh%ncs+2))+cs(msh%ncs+2)*(linear_interp( bc%rat%q ,bc%rat%h ,val0)&
      -(dof%h(msh%ncs+2)+bathy_cell(msh%ncs+2)))-ct(msh%ncs+2)
      dcldval=cr(msh%ncs+2)+cs(msh%ncs+2)*((linear_interp( bc%rat%q ,bc%rat%h ,val0+0.001)&
      -linear_interp( bc%rat%q ,bc%rat%h ,val0-0.001))/(0.002))
      val=val0
      val0=val0-conlim/dcldval
      temp=abs(val-val0)
   end do
   
   dof%q (ie) = val0
   zp1   (ie) =linear_interp( bc%rat%q ,bc%rat%h ,val0)  
  

   dof%h(ie) = zp1(ie)-bathy_cell(ie)
   dof%s(ie)   =HtoS( msh,ie, dof%h(ie) )
   

   !===================================================================================================================!
   !  upwindings
   !===================================================================================================================!
   do ie=msh%ncs+1,3,-1
      zp1(ie)     = Gdj(ie)*(dof%q(ie+1)-q(ie+1)) +Gej(ie)*(zp1(ie+1)-z(ie+1)) + Gfj(ie) +z(ie)
      dof%q(ie)   = (Ct(ie)-Cs(ie)*(zp1(ie)-z(ie)))/cr(ie) +q(ie)
      dof%h(ie)   = zp1(ie)-bathy_cell(ie)
      dof%s(ie)   = HtoS( msh,ie, dof%h(ie) )
   end do
   
END SUBROUTINE preissmann_double_sweep
#endif
