!======================================================================================================================!
!
!                    DassFlow1D Version 2.1
!
!======================================================================================================================!
!
!  Copyright University of Toulouse-INSA - CNRS (France)
!
!  This file is part of the DassFlow software (Data Assimilation for Free Surface Flows).
!  DassFlow is a computational software aiming at simulating geophysical free surface flows.
!  It is designed for Variational Data Assimilation (4D-var) and sensitivity analyses. 
! Inverse capabilities are based on the adjoint code which is generated by 
! a source-to-source algorithmic differentiation (Tapenade software used).
!
!  DassFlow software includes few mostly independent "modules" with common architectures and structures:
!    - DassFlow 2DShallow (shallow water equations in (h,q), finite volumes), i.e. the present code.
!    - DassFlow3D  (non-linear Stokes equations, finite elements, mobile geometries, ALE).
!    - DassFlow 1D (shallow water equations in (S,Q), finite volumes or finite differences), river hydraulics.
!  Please consult the DassFlow webpage for more details: http://www.math.univ-toulouse.fr/DassFlow
!
! You have used DassFlow in an article, a scientific document etc ?  How to cite us ? Please consult the webpage.
! 
!  Many people have contributed to the DassFlow developments from the initial version to the latest ones.
!  Current main developers or scientific contributers are:
!               P. Brisset (CNES & Mathematics Institute of Toulouse & INSA Toulouse)
!               F. Couderc (CNRS & Mathematics Institute of Toulouse IMT)
!               P.-A. Garambois (INSA & ICUBE Strasbourg)
!               J. Monnier (INSA & Mathematics Institute of Toulouse IMT).
!               J.-P. Vila (INSA & Mathematics Institute of Toulouse IMT).
!  and former other developers (R. Madec, M. Honnorat and J. Marin).
!
!  Scientific contact : jerome.monnier@insa-toulouse.fr
!  Technical  contacts : frederic.couderc@math.univ-toulouse.fr, pierre.brisset@insa-toulouse.fr
!
!  This software is governed by the CeCILL license under French law and abiding by the rules of distribution
!  of free software. You can use, modify and/or redistribute the software under the terms of the CeCILL license
!  as circulated by CEA, CNRS and INRIA at the following URL: "http://www.cecill.info".
!
!  As a counterpart to the access to the source code and rights to copy, modify and redistribute granted by the
!  license, users are provided only with a limited warranty and the software's author, the holder of the economic
!  rights, and the successive licensors have only limited liability.
!
!  In this respect, the user's attention is drawn to the risks associated with loading, using, modifying and/or
!  developing or reproducing the software by the user in light of its specific status of free software, that may
!  mean that it is complicated to manipulate, and that also therefore means that it is reserved for developers and
!  experienced professionals having in-depth computer knowledge. Users are therefore encouraged to load and test the
!  software's suitability as regards their requirements in conditions enabling the security of their systems and/or
!  data to be ensured and, more generally, to use and operate it in the same conditions as regards security.
!
!  The fact that you are presently reading this means that you have had knowledge of the CeCILL license and that you
!  accept its terms.
!
!======================================================================================================================!
!> \file m_time_screen.f90
!! \brief This file includes m_time_screen module.
!! \details The file includes only m_time_screen module (see doc m_time_screen module)


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Module controlling Time and Screen Outputs
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

!> Module m_time_screen.
!!
!! \details This module contains all subroutine in relation to the progress of the computation. This module 
!! controlling time and screen outputs.
MODULE m_time_screen

   USE m_common
   USE m_mesh
   
   implicit none

   integer, parameter  ::  max_time_index = 100 !<  Index max of time (For MPI: not used).

   real(rp), dimension( max_time_index )  ::  t_ini !< Initial time of the computation (in sequential case, t_ini is a
   !! scalar).
   real(rp), dimension( max_time_index )  ::  t_end !< End time of the computation (in sequential case, t_ini is a
   !! scalar).
   real(rp), dimension( max_time_index )  ::  time !< Actual time of the computation (in sequential case, t_ini is a
   !! scalar).


CONTAINS


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Initialization of the ième time clock
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

   !> Initialization of the ième time clock. 
   !!
   !! \details This subroutine initializes the \f$i\f$eme time clock. In sequential case, \f$i=1\f$. The vector time 
   !! is assigned the value of 0.
   !! \param[in]    i \f$i\f$ time clock to initialize.
   SUBROUTINE Time_Init( i )

      implicit none

      intrinsic cpu_time

      integer(ip), intent(in)  ::  i

      time( i ) = 0._rp

      call CPU_TIME( t_ini( i ) )
     
   END SUBROUTINE Time_Init


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Stopping of the ième time clock
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

   !> Stopping of the ième time clock. 
   !!
   !! \details This subroutine stops the \f$i\f$eme time clock. In sequential case, \f$i=1\f$. The vector time is equal
   !! to t_end(i) - t_ini(i).
   !! \param[in]    i \f$i\f$ time clock to initialize.
   SUBROUTINE Time_End( i )

      implicit none

      intrinsic cpu_time

      integer(ip), intent(in)  ::  i


      call CPU_TIME( t_end( i ) )
 
      time( i )  =  t_end( i )  -  t_ini( i )

   END SUBROUTINE Time_End


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Initialization of the ième time clock
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

   !> Initialization of the ième time clock. 
   !!
   !! \details This subroutine initializes the \f$i\f$eme time clock. In sequential case, \f$i=1\f$. No modification of
   !! the vector time.
   !! \param[in]    i \f$i\f$ time clock to stop.
   SUBROUTINE Time_Init_Part( i )

      implicit none

      intrinsic cpu_time

      integer(ip), intent(in)  ::  i

      call CPU_TIME( t_ini( i ) )


   END SUBROUTINE Time_Init_Part


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Stopping of the ième time clock
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

   !> Stopping of the ième time clock. 
   !!
   !! \details This subroutine stops the \f$i\f$eme time clock. In sequential case, \f$i=1\f$. The vector time is equal
   !! to time + t_end(i) - t_ini(i).
   !! \param[in]    i \f$i\f$ time clock to stop.
   SUBROUTINE Time_End_Part( i )

      implicit none

      intrinsic cpu_time

      integer(ip), intent(in)  ::  i


      call CPU_TIME( t_end( i ) )
      
      time( i )  =  time( i )  +  t_end( i )  -  t_ini( i )

   END SUBROUTINE Time_End_Part


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Output to screen time clock(s)
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

   !>  Output to screen time clock. 
   !!
   !! \details This subroutine print the time of the simulation, thus the performance to the screen in microsecond.
   !! The performance in a sequential case is equal to the simulation time divise by the size of the msh.
   !! \param[in]    msh Mesh of the model.
   SUBROUTINE Time_Screen( msh )

      implicit none

      TYPE(Mesh), intent(in)  ::  msh

      integer(ip)  ::  mesh_total_size

      mesh_total_size = msh%ncs

      write(6,'(A)'        )
      write(6,'(A)'        ) '********************************************************************************'
      write(6,'(A,F15.2)'  ) ' Time of simulation   =   ' , time(1)
      write(6,'(A)'        ) '********************************************************************************'
      write(6,'(A,F15.2,A)') ' Performance          =   ' , time(1) / mesh_total_size / nt * 1.d6 , &
                                    ' microsecond / dx / dt / proc'
      write(6,'(A)'        ) '********************************************************************************'

   END SUBROUTINE Time_Screen


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Subroutine dedicated to Screen Output Control
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

   !>  Screen Output Control.
   !!
   !! \details All screen output control are done in this subroutine. From a string argument, and a optional variable 
   !! screen are done to informe user on the situation of the computation. Screen can be for example 'Mesh Loading',
   !! 'Mesh Loading is OK', ...
   !! \param[in]    screen_case String parameter used to call some message.
   !! \param[in]    var Optional argument used for send value of cost function, diff cost function or adjoint
   !! cost function.
   SUBROUTINE Print_Screen( screen_case , var )

      implicit none

      intrinsic range , precision

      character(len=*), intent(in)  ::  screen_case

      real(rp), optional, intent(in)  ::  var

      select case( screen_case )

      case( 'read_input' )

         write(6,'(A)')
         write(6,'(A80)') '================================================================================'
         write(6,'(A80)') '*  Loading Input File                                                          *'
         write(6,'(A80)') '================================================================================'

      case( 'start_mesh' )

         write(6,'(A)')
         write(6,'(A80)') '================================================================================'
         write(6,'(A80)') '*  Mesh Loading                                                                *'
         write(6,'(A80)') '================================================================================'

      case( 'end_mesh' )

         write(6,'(A80)') '================================================================================'
         write(6,'(A80)') '*  Mesh Loading is OK                                                          *'
         write(6,'(A80)') '================================================================================'

      case( 'start_read_obs' )

         write(6,'(A)')
         write(6,'(A80)') '================================================================================'
         write(6,'(A80)') '*  Observations Loading                                                        *'
         write(6,'(A80)') '================================================================================'

      case( 'end_read_obs' )

         write(6,'(A80)') '================================================================================'
         write(6,'(A80)') '*  Observations Loading is OK                                                  *'
         write(6,'(A80)') '================================================================================'

      case( 'background_error_covariance' )

         write(6,'(A)')
         write(6,'(A80)') '================================================================================'
         write(6,'(A80)') '*  Computing Background Error Covariance Matrix for Change of Variable         *'
         write(6,'(A80)') '================================================================================'

      case( 'start_direct' )

         write(6,'(A)')
         write(6,'(A80)') '================================================================================'
         write(6,'(A80)') '*  Running Shallow-Water Model in forward mode                                 *'
         write(6,'(A80)') '================================================================================'


      case( 'end_direct' )

         write(6,'(A80)') '================================================================================'
         write(6,'(A80)') '*  End of run of the Shallow-Water Model in forward mod                        *'
         write(6,'(A80)') '================================================================================'

      case( 'start_testadj' )

         write(6,'(A)')
         write(6,'(A80)') '================================================================================'
         write(6,'(A80)') '*  Testing the generated Adjoint to Shallow-Water Model                        *'
         write(6,'(A80)') '================================================================================'

      case( 'end_testadj' )

         write(6,'(A80)') '================================================================================'
         write(6,'(A80)') '*  End of test of the generated Adjoint to Shallow-Water Model                 *'
         write(6,'(A80)') '================================================================================'

      case( 'start_grad_cost' )
         write(6,'(A)')
         write(6,'(A80)') '================================================================================'
         write(6,'(A80)') '*  Running the Shallow-Water Model Adjoint to calculate a cost-gradient        *'
         write(6,'(A80)') '================================================================================'

      case( 'end_grad_cost' )
         write(6,'(A80)') '================================================================================'
         write(6,'(A80)') '*  End of run of the Shallow-Water Model Adjoint                               *'
         write(6,'(A80)') '================================================================================'

      case( 'start_minimize' )
         write(6,'(A)')
         write(6,'(A80)') '================================================================================'
#ifdef USE_M1QN3
         write(6,'(A80)') '*  Running the Shallow-Water loop to minimize the cost function (M1QN3)        *'
#endif
#ifdef USE_N2QN1
         write(6,'(A80)') '*  Running the Shallow-Water loop to minimize the cost function (M2QN1)        *'
#endif
#ifdef USE_LBFGSB3
         write(6,'(A80)') '*  Running the Shallow-Water loop to minimize the cost function (LBFGSB 3.0)   *'
#endif
         write(6,'(A80)') '================================================================================'

      case( 'start_minimize_iterative_regularization' )
         write(6,'(A)')
         write(6,'(A80)') '================================================================================'
         write(6,'(A80)') '*  Running the Shallow-Water loop to minimize the cost function (M1QN3+IR)     *'
         write(6,'(A80)') '================================================================================'

      case( 'restart_min' )
         write(6,'(A80)') '*  Restarting previous minimization                                            *'
         write(6,'(A80)') '================================================================================'

      case( 'rerun_min' )
         write(6,'(A80)') '*  Rerun prior                                                                 *'
         write(6,'(A80)') '================================================================================'

      case( 'end_minimize' )
         write(6,'(A80)') '================================================================================'
         write(6,'(A80)') '*  End of run of the minimization Shallow-Water Model loop                     *'
         write(6,'(A80)') '================================================================================'

      case( 'start_direct_optimum' )

         write(6,'(A)')
         write(6,'(A80)') '================================================================================'
         write(6,'(A80)') '*  Running Shallow-Water Model in direct mode with optimum solution            *'
         write(6,'(A80)') '================================================================================'


      case( 'start_rerun' )

         write(6,'(A)')
         write(6,'(A80)') '================================================================================'
         write(6,'(A,I4.4,A)') '*  Rerun (ite = ', int(var), &
                               ') Shallow-Water Model in direct mode                        *'
         write(6,'(A80)') '================================================================================'


      case( 'end_rerun' )

         write(6,'(A80)') '================================================================================'
         write(6,'(A,I4.4,A)') '*  End of rerun (ite = ', int(var), &
                               ') Shallow-Water Model in direct mode                 *'
         write(6,'(A80)') '================================================================================'

      case( 'result' )

         if ( verbose >= 0 ) then

            write(6,'(A80)') '================================================================================'
            write(6,'(A,ES12.5,A,I4,A)') '*  Writing Result File at t =', tc, ' s ( ', int(tc/86400), ' days )                      *'
            write(6,'(A80)') '================================================================================'
         end if
      case( 'dt' )

         if ( test_dt_just_after( 0.01_rp * ts )  .and. verbose >= 0 ) then

            write(6,'("nt = ",I8," t = ",ES12.5," / ",ES12.5," ( ",F5.1," % ) , dt = ",ES13.6)') &

            nt , tc , ts , 100._rp * tc / ts , dt

          end if

      case( 'number_limits' )

         write(6,'(A)')
         write(6,'(A80)') '********************************************************************************'
         write(6,'(A,I15  )')  ' range     = ' , range(1._rp)
         write(6,'(A,I15  )')  ' precision = ' , precision(1._rp)
         write(6,'(A,ES15.7)') ' zerom     = ' , zerom
         write(6,'(A,ES15.7)') ' pinfm     = ' , pinfm
         write(6,'(A,ES15.7)') ' minfm     = ' , minfm
         write(6,'(A,ES15.7)') ' hugem     = ' , hugem
         write(6,'(A,ES15.7)') ' tinym     = ' , tinym
         write(6,'(A80)') '********************************************************************************'

      case( 'norms_s' )

         write(6,'(A80)') '********************************************************************************'
         write(6,'(A,ES15.7)') ' norm_s_L2   =  ' , norm_L2 (1)
         write(6,'(A80)') '********************************************************************************'

      case( 'norms_q' )

         write(6,'(A80)') '********************************************************************************'
         write(6,'(A,ES15.7)') ' norm_q_L2   =  ' , norm_L2 (2)
         write(6,'(A80)') '********************************************************************************'


      case( 'tangent_gradient_test' )
         write(6,'(A)')
         write(6,'(A80)') '================================================================================'
         write(6,'(A80)') '*  Tangent Gradient Test                                                       *'
         write(6,'(A80)') '================================================================================'

      case( 'backward_gradient_test' )

         write(6,'(A)')
         write(6,'(A80)') '================================================================================'
         write(6,'(A80)') '*  Backward Gradient Test                                                      *'
         write(6,'(A80)') '================================================================================'

      case( 'backward_scalar_product_test' )

         write(6,'(A)')
         write(6,'(A80)') '================================================================================'
         write(6,'(A80)') '*  Backward Scalar Product Test                                                *'
         write(6,'(A80)') '================================================================================'

      case( 'cost' )

         write(6,'(A80)') '================================================================================'
         write(6,'(A,ES24.15)') ' cost function       =  ' , var
         write(6,'(A80)') '================================================================================'

      case( 'cost_diff' )

         write(6,'(A80)') '================================================================================'
         write(6,'(A,ES24.15)') ' diff cost function  =  ' , var
         write(6,'(A80)') '================================================================================'

      case( 'cost_back' )

         write(6,'(A80)') '================================================================================'
         write(6,'(A,ES24.15)') ' back cost function  =  ' , var
         write(6,'(A80)') '================================================================================'

      end select

   END SUBROUTINE Print_Screen


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Stopping Program in case of bad parameter or numeric convergence
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

   !>  Stopping Program in case of bad parameter or numeric convergence.
   !!
   !! \details This subroutine inform users of the reason of the end of the computation by an fail or sucess message.
   !! \param[in]    screen_case String parameter used to call some message.
   SUBROUTINE Stopping_Program( screen_case )

      implicit none

      character(len=*), intent(in)  ::  screen_case

      select case( screen_case )

         case( 'unknow_mesh' )

            write(6,*)
            write(6,'(A80)') '================================================================================'
            write(6,'(A80)') '*  Unknow msh type in input.txt'
            write(6,'(A80)') '================================================================================'

         case default

      end select

      write(6,*)
      write(6,'(A)') '================================================================================'
      write(6,'(A)') '*'
      write(6,'(A)') '*  STOPPING DASSFLOW RUN'
      write(6,'(A)') '*'
      write(6,'(A)') '================================================================================'

   END SUBROUTINE Stopping_Program


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Write at screen a progress bar
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

   !>  Write at screen a progress bar.
   !!
   !! \details This subroutine writes the waitbar from the number of iteration and the actual iteration.
   !! \param[in]    iter Actual iteration.
   !! \param[in]    niter Number of iteration.
   SUBROUTINE waitbar( iter , niter )

	   implicit none

	   integer(ip)  ::  niter , iter , ch , per

      per = 100 * iter / niter   

      if (per /= 100 * ( iter - 1 ) / niter ) then

      	write( 6 , '(                  256a1)' , advance='no' ) ( char(8) , ch = 1 , per/2 + 9 )
         write( 6 , '(2x,1i3,1a1,2x,1a1,256a1)' , advance='no' ) per , '%' , '|' , ( '=' , ch = 1,per/2 )
         close( 6 )
         open ( 6 )

      end if

      if (iter == niter ) write(6,'(a)') '|'

   END SUBROUTINE waitbar


END MODULE m_time_screen
