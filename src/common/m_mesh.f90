!======================================================================================================================!
!
!                    DassFlow Version 2.0
!
!======================================================================================================================!
!
!  Copyright University of Toulouse-INSA - CNRS (France)
!
!  This file is part of the DassFlow software (Data Assimilation for Free Surface Flows).
!  DassFlow is a computational software aiming at simulating geophysical free surface flows.
!  It is designed for Variational Data Assimilation (4D-var) and sensitivity analyses. 
! Inverse capabilities are based on the adjoint code which is generated by 
! a source-to-source algorithmic differentiation (Tapenade software used).
!
!  DassFlow software includes few mostly independent "modules" with common architectures and structures:
!    - DassFlow 2DShallow (shallow water equations in (h,q), finite volumes), i.e. the present code.
!    - DassFlow3D  (non-linear Stokes equations, finite elements, mobile geometries, ALE).
!    - DassFlow 1D (shallow water equations in (S,Q), finite volumes or finite differences), river hydraulics.
!  Please consult the DassFlow webpage for more details: http://www.math.univ-toulouse.fr/DassFlow
!
! You have used DassFlow in an article, a scientific document etc ?  How to cite us ? Please consult the webpage.
! 
!  Many people have contributed to the DassFlow developments from the initial version to the latest ones.
!  Current main developers or scientific contributers are:
!               P. Brisset (CNES & Mathematics Institute of Toulouse & INSA Toulouse)
!               F. Couderc (CNRS & Mathematics Institute of Toulouse IMT)
!               P.-A. Garambois (INSA & ICUBE Strasbourg)
!               J. Monnier (INSA & Mathematics Institute of Toulouse IMT).
!               J.-P. Vila (INSA & Mathematics Institute of Toulouse IMT).
!  and former other developers (R. Madec, M. Honnorat and J. Marin).
!
!  Scientific contact : jerome.monnier@insa-toulouse.fr
!  Technical  contacts : frederic.couderc@math.univ-toulouse.fr, pierre.brisset@insa-toulouse.fr
!
!  This software is governed by the CeCILL license under French law and abiding by the rules of distribution
!  of free software. You can use, modify and/or redistribute the software under the terms of the CeCILL license
!  as circulated by CEA, CNRS and INRIA at the following URL: "http://www.cecill.info".
!
!  As a counterpart to the access to the source code and rights to copy, modify and redistribute granted by the
!  license, users are provided only with a limited warranty and the software's author, the holder of the economic
!  rights, and the successive licensors have only limited liability.
!
!  In this respect, the user's attention is drawn to the risks associated with loading, using, modifying and/or
!  developing or reproducing the software by the user in light of its specific status of free software, that may
!  mean that it is complicated to manipulate, and that also therefore means that it is reserved for developers and
!  experienced professionals having in-depth computer knowledge. Users are therefore encouraged to load and test the
!  software's suitability as regards their requirements in conditions enabling the security of their systems and/or
!  data to be ensured and, more generally, to use and operate it in the same conditions as regards security.
!
!  The fact that you are presently reading this means that you have had knowledge of the CeCILL license and that you
!  accept its terms.
!
!======================================================================================================================!
!> \file m_mesh.f90
!! \brief This file includes m_mesh module.
!! \details The file includes only m_mesh module (see doc m_mesh module).

!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Module m_mesh
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

!> Module m_mesh.
!!
!! \details This module includes mesh, cross section and point structure and subroutine alloc/deallocation of the
!! cross section
module m_mesh
    use m_common
    use m_linear_algebra
    implicit none
    
    integer(2), parameter :: K_constant = 1
    integer(2), parameter :: K_powerlaw_h = 2
    integer(2), parameter :: K_einstein = 3
    integer(2), parameter :: strickler_type_constant = 1
    integer(2), parameter :: strickler_type_powerlaw_h = 2
#ifdef STRICKLER_EINSTEIN
    integer(2), parameter :: strickler_type_einstein = 3
#endif
#ifdef AVERAGE_CONVEYANCE
    integer(2), parameter :: strickler_type_average_conveyance = 4
#endif
#ifdef DEBORD_FORMULA
    integer(2), parameter :: strickler_type_debord = 5
#endif

    !> Structure of a cross section.
    type Crosssection
        
        !> Planar coordinates
        type(vec2d) :: coord
        !> Curvilinear abscissa
        real(rp) :: x
        !> Index of cross-section in base list
        integer(ip) :: ibase
        !> Index of current level
        integer(ip) :: level
        !> Number of discretization levels
        integer(ip) :: nlevels
        !> Indices of overbanks levels (1=left, 2=right)
        integer(ip) :: ob_levels(2)
#ifdef FLOODPLAIN_MODEL
        !> Shape coefficient for floodplain
        real(rp) :: alphaFP
#endif
        !> Bathymetry height
        real(rp) :: bathy
        !> Distance between x(i-1/2) and x(i+1/2)
        real(rp) :: delta
        !> Distance between x(i-1) and x(i)
        real(rp) :: deltademi
        !> Slope
        real(rp) :: slope
        !> Array of levels heights
        real(rp), dimension(:), allocatable :: level_heights
        !> Array of levels widths
        real(rp), dimension(:), allocatable :: level_widths
        !> Array of displacements ! TODO DEPRECATED
        real(rp), dimension(:), allocatable :: y
        !> Strickler type
        integer(2) :: strickler_type_code
        !> Array of Strickler parameters
        real(rp), dimension(:), allocatable :: strickler_params
        !> Array of polynoms coefficients for each level
        !> \details Each row corresponds to a level and each column to power of H (H^p, H^{p-1}, ..., H^0)
        real(rp), dimension(:, :), allocatable :: poly
        !> Array of cumulated flow area between levels 0 and k
        real(rp), dimension(:), allocatable :: area_cum
        !> Array of cumulated wetted perimeter between levels 0 and k
        real(rp), dimension(:), allocatable :: perim_cum
        !> Array of cumulated Pa between levels 0 and k
        real(rp), dimension(:), allocatable :: pa_cum

    end type Crosssection


    !> Structure of spatial field
    type SpatialField
        character(len=8) :: interp = "none"
        real(rp), dimension(:), allocatable  ::  x  !< Curvilinear abscissa array.
        real(rp), dimension(:), allocatable  ::  y  !< Flow array.
    end type


    !> Structure of a segment.
    type Segment
                
        !> Index of first cross-section
        integer(ip) :: first_cs
        !> Index of last cross-section
        integer(ip) :: last_cs
        !> Index of downstream segment
        integer(ip) :: ds_seg
        !> Indices of upstream segments
        integer(ip), dimension(:), allocatable :: us_seg
        !> Index of downstream BC (only for a segment with no downstream segment)
        integer(ip) :: ds_bc
        !> Index of upstream BC (only for a segment with no upstream segments)
        integer(ip) :: us_bc
        type(SpatialField), dimension(:), allocatable :: strickler_fields
        type(SpatialField) :: bathy_field

    end type Segment


    !> Structure of a mesh.
    type Mesh
                
        !> Number of cross-sections
        integer(ip) :: ncs
        !> Number of segments
        integer(ip) :: nseg
        !> Array of cross-sections
        type(Crosssection), dimension(:), allocatable :: cs
        !> Array of segments
        type(Segment), dimension(:), allocatable :: seg
        
        logical :: has_ghost_cells
!         type(SpatialField) :: bathy_field
        character(len=16) :: strickler_type = "powerlaw_h"
        integer(2) :: strickler_type_code = strickler_type_powerlaw_h
    
!         character(len=lchar) :: file_name                                     !< Name of the mesh file.
! 
!         real(rp), dimension(:), allocatable :: dx                             !< Distance between cross section

!         real(rp) :: scal                                                        !< Scale (not used)

    end type Mesh


    !> Structure of point in mesh.
    !!
    !! \details Coordinates of the node belong to the mesh structure.
    type point_in_mesh

        type(vec2d) :: coord !< Coordinates of the node.   

        integer(ip) :: indexi  !< Number of the node.   

    end type point_in_mesh
    
    
#ifndef CPP_ADJ
    ! Interfaces to routines and functions defined in base/geometry.f90
    interface
        subroutine compute_levels_poly(cs)
            import Crosssection
            implicit none
            type(Crosssection), intent(inout) :: cs
        end subroutine
        subroutine compute_levels_cum(cs)
            import Crosssection
            implicit none
            type(Crosssection), intent(inout) :: cs
        end subroutine
        subroutine update_level(cs, h)
            import Crosssection
            import rp
            implicit none
            type(Crosssection), intent(inout) :: cs
            real(rp), intent(in) :: h
        end subroutine
        subroutine update_level_from_area(cs, area)
            import Crosssection
            import rp
            implicit none
            type(Crosssection), intent(inout) :: cs
            real(rp), intent(in) :: area
        end subroutine
        function htoA(cs, h) result(A)
            import Crosssection
            import rp
            implicit none
            type(Crosssection), intent(inout) :: cs
            real(rp), intent(in) :: h
            real(rp) :: A
        end function
        function htoA_noupdate(cs, h) result(A)
            import Crosssection
            import rp
            implicit none
            type(Crosssection), intent(inout) :: cs
            real(rp), intent(in) :: h
            real(rp) :: A
        end function
        function htoP(cs, h) result(P)
            import Crosssection
            import rp
            implicit none
            type(Crosssection), intent(inout) :: cs
            real(rp), intent(in) :: h
            real(rp) :: P
        end function
        function htoP_noupdate(cs, h) result(P)
            import Crosssection
            import rp
            implicit none
            type(Crosssection), intent(inout) :: cs
            real(rp), intent(in) :: h
            real(rp) :: P
        end function
        function htoW(cs, h) result(W)
            import Crosssection
            import rp
            implicit none
            type(Crosssection), intent(inout) :: cs
            real(rp), intent(in) :: h
            real(rp) :: W
        end function
        function htoW_noupdate(cs, h) result(W)
            import Crosssection
            import rp
            implicit none
            type(Crosssection), intent(inout) :: cs
            real(rp), intent(in) :: h
            real(rp) :: W
        end function
        function Atoh(cs, A) result(h)
            import Crosssection
            import rp
            implicit none
            type(Crosssection), intent(inout) :: cs
            real(rp), intent(in) :: A
            real(rp) :: h
        end function
        function Atoh_noupdate(cs, A) result(h)
            import Crosssection
            import rp
            implicit none
            type(Crosssection), intent(inout) :: cs
            real(rp), intent(in) :: A
            real(rp) :: h
        end function
  !       subroutine height(cs, h, value)
  !           import Crosssection
  !           import rp
  !           implicit none
  !           type(Crosssection), intent(in) :: cs
  !           real(rp), intent(in) :: h
  !           real(rp), intent(out) :: value
  !       end subroutine
        subroutine width(cs, h, value)
            import Crosssection
            import rp
            implicit none
            type(Crosssection), intent(in) :: cs
            real(rp), intent(in) :: h
            real(rp), intent(out) :: value      
        end subroutine
        subroutine widths_compound_channel(cs, h, values)
            import Crosssection
            import rp
            implicit none
            type(Crosssection), intent(inout) :: cs
            real(rp), intent(in) :: h
            real(rp), dimension(3), intent(inout) :: values
        end subroutine
        subroutine depth_from_area(cs, area, h)
            import Crosssection
            import rp
            implicit none
            type(Crosssection), intent(in) :: cs
            real(rp), intent(in) :: area
            real(rp), intent(out) :: h      
        end subroutine
        subroutine area(cs, h, value)
            import Crosssection
            import rp
            implicit none
            type(Crosssection), intent(in) :: cs
            real(rp), intent(in) :: h
            real(rp), intent(out) :: value      
        end subroutine
        subroutine areas_compound_channel(cs, h, values)
            import Crosssection
            import rp
            implicit none
            type(Crosssection), intent(inout) :: cs
            real(rp), intent(in) :: h
            real(rp), dimension(3), intent(inout) :: values
        end subroutine
        subroutine perimeter(cs, h, value)
            import Crosssection
            import rp
            implicit none
            type(Crosssection), intent(in) :: cs
            real(rp), intent(in) :: h
            real(rp), intent(out) :: value      
        end subroutine
        subroutine perimeters_compound_channel(cs, h, values)
            import Crosssection
            import rp
            implicit none
            type(Crosssection), intent(inout) :: cs
            real(rp), intent(in) :: h
            real(rp), dimension(3), intent(inout) :: values
        end subroutine
        subroutine strickler(cs, h, value)
            import Crosssection
            import rp
            implicit none
            type(Crosssection), intent(in) :: cs
            real(rp), intent(in) :: h
            real(rp), intent(out) :: value      
        end subroutine
        subroutine pressure(cs, h, gravity, value)
            import Crosssection
            import rp
            implicit none
            type(Crosssection), intent(in) :: cs
            real(rp), intent(in) :: h
            real(rp), intent(in) :: gravity
            real(rp), intent(out) :: value
        end subroutine
        subroutine Sg(cs, csm1, csp1, h, gravity, value)
            import Crosssection
            import rp
            implicit none
            type(Crosssection), intent(in) :: cs
            type(Crosssection), intent(in) :: csm1
            type(Crosssection), intent(in) :: csp1
            real(rp), intent(in) :: h
            real(rp), intent(in) :: gravity
            real(rp), intent(out) :: value      
        end subroutine
        subroutine dPdZ(cs, h, value)
            import Crosssection
            import rp
            implicit none
            type(Crosssection), intent(in) :: cs
            real(rp), intent(in) :: h
            real(rp), intent(out) :: value      
        end subroutine
        subroutine dPdZ_compound_channel(cs, h, values)
            import Crosssection
            import rp
            implicit none
            type(Crosssection), intent(inout) :: cs
            real(rp), intent(in) :: h
            real(rp), dimension(2), intent(inout) :: values
        end subroutine
        subroutine dKdZ(cs, h, value)
            import Crosssection
            import rp
            implicit none
            type(Crosssection), intent(in) :: cs
            real(rp), intent(in) :: h
            real(rp), intent(out) :: value      
        end subroutine
        subroutine compute_all_levels_cum(msh)
            import Mesh
            implicit none
            type(Mesh), intent(inout) :: msh
        end subroutine
        subroutine update_all_levels(msh, h)
            import Mesh
            import rp
            implicit none
            type(Mesh), intent(inout) :: msh
            real(rp), dimension(msh%ncs), intent(in) :: h
        end subroutine
        function search_nearest_cross_section(msh, point) result(indexi)
            import Mesh
            import vec2d
            import ip
            implicit none
            type(Mesh), intent(in)  ::  msh
            type(vec2d), intent(in)  ::  point
            integer(ip)  ::  indexi , temp_indexi
        end function
    end interface

    ! Interfaces to routines defined in base/read_spatial_field.f90
    interface
        subroutine read_spatial_field(msh, filename)
            import Mesh
            import rp
            implicit none
            type(Mesh), intent(inout) :: msh
            character(len=*), intent(in) :: filename
        end subroutine
    end interface

    ! Interfaces to routines defined in base/apply_bathy_field.f90
    interface
        subroutine apply_bathy_field(msh, eps)
            import Mesh
            import rp
            implicit none
            type(Mesh), intent(inout) :: msh
            real(rp), intent(in) :: eps
        end subroutine
    end interface

    ! Interfaces to routines defined in base/apply_strickler_fields.f90
    interface
        subroutine apply_strickler_fields(msh)
            import Mesh
            import rp
            implicit none
            type(Mesh), intent(inout) :: msh
        end subroutine
    end interface

!     ! Interfaces to routines defined in base/bathy_slopes.f90
!     interface
!         subroutine bathy_slopes(msh)
!             import Mesh
!             implicit none
!             type(Mesh), intent(inout) :: msh
!         end subroutine
!     end interface

    ! Interfaces to routines defined in base/curvilinear_abscissae.f90
    interface
        subroutine curvilinear_abscissae_from_coords(msh)
            import Mesh
            implicit none
            type(Mesh), intent(inout) :: msh
        end subroutine
        subroutine finalise_curvilinear_abscissae(msh)
            import Mesh
            implicit none
            type(Mesh), intent(inout) :: msh
        end subroutine
    end interface

!     ! Interfaces to routines defined in base/resample_mesh.f90
!     interface
!         subroutine resample_mesh(msh, dxs)
!             import Mesh
!             import rp
!             implicit none
!             type(Mesh), intent(inout) :: msh
!             real(rp), intent(in) :: dxs
!         end subroutine
!     end interface
#endif


#ifndef CPP_ADJ  
    contains
  

    subroutine crosssection_initialise(cs, nlevels, shape_model)
        implicit none
        type(Crosssection), intent(inout) :: cs
        integer(ip), intent(in) :: nlevels
        character(len=lchar), intent(in), optional :: shape_model
        
        integer :: order
        
!         print *, "initialise Crosssection", loc(cs)
        if (present(shape_model)) then
            select case(shape_model)
                case("linear")
                    order = 1
                case("cubic_spline")
                    order = 3
                case default
                    call f90wrap_abort("Unknown 'shape_model' "//trim(shape_model))
            end select
        else
            order = 1
        end if
        
        allocate(cs%level_heights(nlevels))
        cs%level_heights(:) = 0.0_rp
        allocate(cs%level_widths(nlevels))
        cs%level_widths(:) = 0.0_rp
        allocate(cs%y(nlevels))
        cs%y(:) = 0.0_rp
        cs%ob_levels(:) = 0
        cs%strickler_type_code = strickler_type_powerlaw_h
#if defined(STRICKLER_EINSTEIN) || defined(AVERAGE_CONVEYANCE)
        allocate(cs%strickler_params(3))
        cs%strickler_params(:) = 0.0_rp
#else
        allocate(cs%strickler_params(2))
        cs%strickler_params(:) = 0.0_rp
#endif
        allocate(cs%poly(order+1, nlevels))
        cs%poly(:, :) = 0.0_rp
        cs%nlevels = nlevels

        allocate(cs%area_cum(0:nlevels))
        cs%area_cum(:) = 0.0_rp
        allocate(cs%perim_cum(0:nlevels))
        cs%perim_cum(:) = 0.0_rp
        allocate(cs%pa_cum(0:nlevels))
        cs%pa_cum(:) = 0.0_rp
        
        cs%level = 0
#ifdef FLOODPLAIN_MODEL
        cs%alphaFP = 0.001
#endif
        
    
    end subroutine


    subroutine crosssection_finalise(cs)
        implicit none
        type(Crosssection), intent(inout) :: cs
        
        if (allocated(cs%level_heights)) deallocate(cs%level_heights)
        if (allocated(cs%level_widths)) deallocate(cs%level_widths)
        if (allocated(cs%y)) deallocate(cs%y)
        if (allocated(cs%strickler_params)) deallocate(cs%strickler_params)
        if (allocated(cs%poly)) deallocate(cs%poly)
        if (allocated(cs%area_cum)) deallocate(cs%area_cum)
        if (allocated(cs%perim_cum)) deallocate(cs%perim_cum)
        if (allocated(cs%pa_cum)) deallocate(cs%pa_cum)
        
    end subroutine
  

    subroutine set_coords(cs, x, y)
        implicit none
        type(Crosssection), intent(inout) :: cs
        real(rp), intent(in) :: x
        real(rp), intent(in) :: y
  
        cs%coord%x = x
        cs%coord%y = y
    
    end subroutine


    subroutine set_levels(cs, heights, widths, shape_model)
        implicit none
        type(Crosssection), intent(inout) :: cs
        real(rp), dimension(:), intent(in) :: heights
        real(rp), dimension(:), intent(in) :: widths
        character(len=lchar), intent(in), optional :: shape_model
        
        integer :: nlevels
        integer :: order
        
        if (present(shape_model)) then
            select case(shape_model)
                case("linear")
                    order = 1
                case("cubic_spline")
                    order = 3
                case default
                    call f90wrap_abort("Unknown 'shape_model' "//trim(shape_model))
            end select
        else
            order = 1
        end if
        
        nlevels = size(heights)
        
        allocate(cs%level_heights(nlevels))
        cs%level_heights(:) = heights(:)
        allocate(cs%level_widths(nlevels))
        cs%level_widths(:) = widths(:)
        allocate(cs%y(nlevels))
        cs%y(:) = 0.0_rp
        cs%ob_levels(:) = 0
#if defined(STRICKLER_EINSTEIN) || defined(AVERAGE_CONVEYANCE)
        allocate(cs%strickler_params(3))
#else
        allocate(cs%strickler_params(2))
#endif
        cs%strickler_params(:) = 0.0_rp
        allocate(cs%poly(order+1, nlevels))
        cs%poly(:, :) = 0.0_rp
        cs%nlevels = nlevels

        allocate(cs%area_cum(0:nlevels))
        cs%area_cum(:) = 0.0_rp
        allocate(cs%perim_cum(0:nlevels))
        cs%perim_cum(:) = 0.0_rp
        allocate(cs%pa_cum(0:nlevels))
        cs%pa_cum(:) = 0.0_rp
        
        cs%level = 0
    
    end subroutine


    subroutine set_overbanks_levels(cs, level_left, level_right)
        implicit none
        type(Crosssection), intent(inout) :: cs
        integer(ip), intent(in) :: level_left
        integer(ip), intent(in) :: level_right
        
        ! TODO check levels
        
        cs%ob_levels(1) = level_left
        cs%ob_levels(2) = level_right
        
    end subroutine

    subroutine crosssection_copy(cs_src, cs_dst)
        implicit none
        type(Crosssection), intent(in) :: cs_src
        type(Crosssection), intent(inout) :: cs_dst
        
        call crosssection_finalise(cs_dst)
        
        ! Copy scalars
        cs_dst%coord%x = cs_src%coord%x
        cs_dst%coord%y = cs_src%coord%y
        cs_dst%x = cs_src%x
        cs_dst%ibase = cs_src%ibase
        cs_dst%level = cs_src%level
        cs_dst%nlevels = cs_src%nlevels
        cs_dst%ob_levels(:) = cs_src%ob_levels(:)
#ifdef FLOODPLAIN_MODEL
        cs_dst%alphaFP = cs_src%alphaFP
#endif
        cs_dst%bathy = cs_src%bathy
        cs_dst%delta = cs_src%delta
        cs_dst%deltademi = cs_src%deltademi
        cs_dst%slope = cs_src%slope
        cs_dst%strickler_type_code = cs_src%strickler_type_code
        ! Copy arrays
        if (allocated(cs_src%level_heights)) then
            allocate(cs_dst%level_heights(size(cs_src%level_heights)))
            cs_dst%level_heights(:) = cs_src%level_heights(:)
        end if
        if (allocated(cs_src%level_widths)) then
            allocate(cs_dst%level_widths(size(cs_src%level_widths)))
            cs_dst%level_widths(:) = cs_src%level_widths(:)
        end if
        if (allocated(cs_src%y)) then
            allocate(cs_dst%y(size(cs_src%y)))
            cs_dst%y(:) = cs_src%y(:)
        end if
        if (allocated(cs_src%strickler_params)) then
            allocate(cs_dst%strickler_params(size(cs_src%strickler_params)))
            cs_dst%strickler_params(:) = cs_src%strickler_params(:)
        end if
        if (allocated(cs_src%poly)) then
            allocate(cs_dst%poly(size(cs_src%poly, 1), size(cs_src%poly, 2)))
            cs_dst%poly(:, :) = cs_src%poly(:, :)
        end if
        if (allocated(cs_src%area_cum)) then
            allocate(cs_dst%area_cum(0:size(cs_src%area_cum)-1))
            cs_dst%area_cum(:) = cs_src%area_cum(:)
        end if
        if (allocated(cs_src%perim_cum)) then
            allocate(cs_dst%perim_cum(0:size(cs_src%perim_cum)-1))
            cs_dst%perim_cum(:) = cs_src%perim_cum(:)
        end if
        if (allocated(cs_src%pa_cum)) then
            allocate(cs_dst%pa_cum(0:size(cs_src%pa_cum)-1))
            cs_dst%pa_cum(:) = cs_src%pa_cum(:)
        end if
        
    end subroutine


    subroutine update_geometry(cs)
        implicit none
        type(Crosssection), intent(inout) :: cs
        
        call compute_levels_poly(cs)
        call compute_levels_cum(cs)
        
    end subroutine


    subroutine crosssection_compute_levels_poly(cs)
!         import Crosssection
        implicit none
        type(Crosssection), intent(inout) :: cs
        call compute_levels_poly(cs)
    end subroutine


    subroutine crosssection_compute_levels_cum(cs)
!         import Crosssection
        implicit none
        type(Crosssection), intent(inout) :: cs
        call compute_levels_cum(cs)
    end subroutine
    
    
    subroutine crosssection_update_level(cs, h)
!         import Crosssection
!         import rp
        implicit none
        type(Crosssection), intent(inout) :: cs
        real(rp), intent(in) :: h
        call update_level(cs, h)
    end subroutine
    
        
    subroutine crosssection_update_level_from_area(cs, area)
!         import Crosssection
!         import rp
        implicit none
        type(Crosssection), intent(inout) :: cs
        real(rp), intent(in) :: area
        call update_level_from_area(cs, area)
    end subroutine
    
        
    function crosssection_htoA(cs, h) result(A)
!         import Crosssection
!         import rp
        implicit none
        type(Crosssection), intent(inout) :: cs
        real(rp), intent(in) :: h
        real(rp) :: A
        A = htoA(cs, h)
    end function
        
        
    function crosssection_htoA_noupdate(cs, h) result(A)
!         import Crosssection
!         import rp
        implicit none
        type(Crosssection), intent(inout) :: cs
        real(rp), intent(in) :: h
        real(rp) :: A
        A = htoA_noupdate(cs, h)
    end function

        
    function crosssection_htoP(cs, h) result(P)
!         import Crosssection
!         import rp
        implicit none
        type(Crosssection), intent(inout) :: cs
        real(rp), intent(in) :: h
        real(rp) :: P
        P = htoP(cs, h)
    end function
        
        
    function crosssection_htoP_noupdate(cs, h) result(P)
!         import Crosssection
!         import rp
        implicit none
        type(Crosssection), intent(inout) :: cs
        real(rp), intent(in) :: h
        real(rp) :: P
        P = htoP_noupdate(cs, h)
    end function
        
        
    function crosssection_htoW(cs, h) result(W)
!         import Crosssection
!         import rp
        implicit none
        type(Crosssection), intent(inout) :: cs
        real(rp), intent(in) :: h
        real(rp) :: W
        W = htoW(cs, h)
    end function
    
        
    function crosssection_htoW_noupdate(cs, h) result(W)
!         import Crosssection
!         import rp
        implicit none
        type(Crosssection), intent(inout) :: cs
        real(rp), intent(in) :: h
        real(rp) :: W
        W = htoW_noupdate(cs, h)
    end function
        
        
    function crosssection_Atoh(cs, A) result(h)
!         import Crosssection
!         import rp
        implicit none
        type(Crosssection), intent(inout) :: cs
        real(rp), intent(in) :: A
        real(rp) :: h
        h = Atoh(cs, A)
    end function
    
        
    function crosssection_Atoh_noupdate(cs, A) result(h)
!             import Crosssection
!             import rp
        implicit none
        type(Crosssection), intent(inout) :: cs
        real(rp), intent(in) :: A
        real(rp) :: h
        h = Atoh_noupdate(cs, A)
    end function
  !       subroutine height(cs, h, value)
  !           import Crosssection
  !           import rp
  !           implicit none
  !           type(Crosssection), intent(in) :: cs
  !           real(rp), intent(in) :: h
  !           real(rp), intent(out) :: value
  !       end subroutine
  
    subroutine crosssection_width(cs, h, value)
!         import Crosssection
!         import rp
        implicit none
        type(Crosssection), intent(in) :: cs
        real(rp), intent(in) :: h
        real(rp), intent(out) :: value
        call width(cs, h, value)
    end subroutine
    
        
    subroutine crosssection_widths_compound_channel(cs, h, values)
!         import Crosssection
!         import rp
        implicit none
        type(Crosssection) :: cs
        real(rp), intent(in) :: h
        real(rp), dimension(3), intent(inout) :: values
        call widths_compound_channel(cs, h, values)
    end subroutine
    
        
    subroutine crosssection_depth_from_area(cs, area, h)
!         import Crosssection
!         import rp
        implicit none
        type(Crosssection), intent(in) :: cs
        real(rp), intent(in) :: area
        real(rp), intent(out) :: h
        call depth_from_area(cs, area, h)
    end subroutine
        
        
    subroutine crosssection_area(cs, h, value)
!         import Crosssection
!         import rp
        implicit none
        type(Crosssection), intent(in) :: cs
        real(rp), intent(in) :: h
        real(rp), intent(out) :: value
        call area(cs, h, value)
    end subroutine
    
        
    subroutine crosssection_areas_compound_channel(cs, h, values)
!         import Crosssection
!         import rp
        implicit none
        type(Crosssection) :: cs
        real(rp), intent(in) :: h
        real(rp), dimension(3), intent(inout) :: values
        call areas_compound_channel(cs, h, values)
    end subroutine
        
        
    subroutine crosssection_perimeter(cs, h, value)
!             import Crosssection
!             import rp
        implicit none
        type(Crosssection), intent(in) :: cs
        real(rp), intent(in) :: h
        real(rp), intent(out) :: value
        call perimeter(cs, h, value)
    end subroutine
    
    
    subroutine crosssection_perimeters_compound_channel(cs, h, values)
        implicit none
        type(Crosssection) :: cs
        real(rp), intent(in) :: h
        real(rp), dimension(3), intent(inout) :: values
        
        call perimeters_compound_channel(cs, h, values)
        
    end subroutine
    

    subroutine crosssection_strickler(cs, h, value)
        implicit none
        type(Crosssection), intent(in) :: cs
        real(rp), intent(in) :: h
        real(rp), intent(out) :: value
        call strickler(cs, h, value)
    end subroutine

        
    subroutine crosssection_pressure(cs, h, gravity, value)
!         import Crosssection
!         import rp
        implicit none
        type(Crosssection), intent(in) :: cs
        real(rp), intent(in) :: h
        real(rp), intent(in) :: gravity
        real(rp), intent(out) :: value
        call pressure(cs, h, gravity, value)
    end subroutine
    
        
    subroutine crosssection_Sg(cs, csm1, csp1, h, gravity, value)
!         import Crosssection
!         import rp
        implicit none
        type(Crosssection), intent(in) :: cs
        type(Crosssection), intent(in) :: csm1
        type(Crosssection), intent(in) :: csp1
        real(rp), intent(in) :: h
        real(rp), intent(in) :: gravity
        real(rp), intent(out) :: value
        call Sg(cs, csm1, csp1, h, gravity, value)
    end subroutine
    
        
    subroutine crosssection_dPdZ(cs, h, value)
!         import Crosssection
!         import rp
        implicit none
        type(Crosssection), intent(in) :: cs
        real(rp), intent(in) :: h
        real(rp), intent(out) :: value
        call dPdZ(cs, h, value)
    end subroutine
        
        
    subroutine crosssection_dPdZ_compound_channel(cs, h, values)
!         import Crosssection
!         import rp
        implicit none
        type(Crosssection) :: cs
        real(rp), intent(in) :: h
        real(rp), dimension(2), intent(inout) :: values
        call dPdZ_compound_channel(cs, h, values)
    end subroutine
        
        
    subroutine crosssection_dKdZ(cs, h, value)
!             import Crosssection
!             import rp
        implicit none
        type(Crosssection), intent(in) :: cs
        real(rp), intent(in) :: h
        real(rp), intent(out) :: value
        
        call dKdZ(cs, h, value)
    end subroutine
        
        
!     subroutine mesh_compute_all_levels_cum(msh)
! !         import Mesh
!         implicit none
!         type(Mesh), intent(inout) :: msh
!         
!         call compute_all_levels_cum(msh)
!     end subroutine
! 
!         
!     subroutine mesh_update_all_levels(msh, h)
! !         import Mesh
! !         import rp
!         implicit none
!         type(Mesh), intent(inout) :: msh
!         real(rp), dimension(msh%ncs), intent(in) :: h
!         call update_all(msh, h)
!     end subroutine
! 
!         
!     function mesh_search_nearest_cross_section(msh, point) result(indexi)
! !             import Mesh
! !             import vec2d
! !             import ip
!         implicit none
!         type(Mesh), intent(in)  ::  msh
!         type(vec2d), intent(in)  ::  point
!         integer(ip)  ::  indexi , temp_indexi
!         
!         indexi = search_nearest_cross_section(mesh, point)
!         
!     end function    


    !> Allocate are cross section array.
    !! \param[out] var Array of the size of the number of cross section.
    !! \param[in] mesh Mesh structure.
    subroutine alloc_Crosssection(var, msh)
        implicit none

        type(Mesh), intent(in) :: msh                           

        real(rp), dimension(:), allocatable, intent(out) :: var   
        
        allocate( var( msh%ncs ) )   

        var(:)  =  0._rp 

    end subroutine alloc_Crosssection

!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Increase or Decrease Allocated Mesh Array Memory
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!
    !>  Increase or Decrease Allocated Mesh Array Memory
    !! \param[out] var Array of the size of the number of cross section.
    !! \param[in] new size of the new cross section.
    subroutine reallocate_Crosssection( var , new )

        implicit none

        type(Crosssection), dimension(:), allocatable, intent(inout) :: var

        integer(ip), intent(in) :: new

        integer(ip) :: old

        type(Crosssection), dimension(:), allocatable :: temp

        intrinsic move_alloc

        old = size(var)

        if      ( new == old ) then

            return

        else if ( new  < old ) then

            allocate( temp( new ) )

            temp( 1 : new ) = var( 1 : new )

            call move_alloc( temp , var )

        else

            allocate( temp( new ) )

            temp( 1 : old ) = var( : )

            call move_alloc( temp , var )

        end if

    end subroutine reallocate_Crosssection


    subroutine spatialfield_finalise(field)
        implicit none
        type(SpatialField), intent(inout) :: field

        if (allocated(field%x)) deallocate(field%x)
        if (allocated(field%y)) deallocate(field%y)

    end subroutine


    subroutine spatialfield_copy(field_src, field_dst)
        implicit none
        type(SpatialField), intent(in) :: field_src
        type(SpatialField), intent(inout) :: field_dst

        call spatialfield_finalise(field_dst)
        
        field_dst%interp = field_src%interp
        if (allocated(field_src%x)) then
            allocate(field_dst%x(size(field_src%x)))
            field_dst%x(:) = field_src%x(:)
        end if
        if (allocated(field_src%y)) then
            allocate(field_dst%y(size(field_src%y)))
            field_dst%y(:) = field_src%y(:)
        end if

    end subroutine
  
  
    subroutine segment_initialise(seg, nus_segs)
        implicit none
        type(Segment), intent(inout) :: seg
        !> Number of upstream segments
        integer, intent(in) :: nus_segs
        
        allocate(seg%us_seg(nus_segs))
        seg%us_seg(:) = -1
    
    end subroutine
  
  
    subroutine segment_finalise(seg)
        implicit none
        type(Segment), intent(inout) :: seg
    
        if (allocated(seg%us_seg)) deallocate(seg%us_seg)
    
    end subroutine


    subroutine segment_copy(seg_src, seg_dst)
        implicit none
        type(Segment), intent(in) :: seg_src
        type(Segment), intent(inout) :: seg_dst
        integer(ip) :: ifield
        
        call segment_finalise(seg_dst)
        
        ! Copy cross-sections indices
        seg_dst%first_cs = seg_src%first_cs
        seg_dst%last_cs = seg_src%last_cs

        ! Copy connected segments indices
        seg_dst%ds_seg = seg_src%ds_seg
        if (allocated(seg_src%us_seg)) then
            allocate(seg_dst%us_seg(size(seg_src%us_seg)))
            seg_dst%us_seg(:) = seg_src%us_seg(:)
        end if

        ! Copy BC indices
        seg_dst%ds_bc = seg_src%ds_bc
        seg_dst%us_bc = seg_src%us_bc

        ! Copy spatial fields
        if (allocated(seg_src%strickler_fields)) then
            allocate(seg_dst%strickler_fields(size(seg_src%strickler_fields)))
            do ifield = 1, size(seg_src%strickler_fields)
                call spatialfield_copy(seg_src%strickler_fields(ifield), seg_dst%strickler_fields(ifield))
            end do
        end if
        call spatialfield_copy(seg_src%bathy_field, seg_dst%bathy_field)
        
    end subroutine
  
  
    subroutine set_crosssections_range(seg, first_cs, last_cs)
        implicit none
        type(Segment), intent(inout) :: seg
        !> Index of first cross-section (0-indexed)
        integer(ip), intent(in) :: first_cs
        !> Index of last cross-section (0-indexed)
        integer(ip), intent(in) :: last_cs
        
        seg%first_cs = first_cs + 1
        seg%last_cs = last_cs + 1
    
    end subroutine
  
  
    subroutine set_connectivity(seg, upstream_segments, downstream_segment)
        implicit none
        type(Segment), intent(inout) :: seg
        ! Indices of upstream segments (O-indexed)
        integer(ip), dimension(:), intent(in) :: upstream_segments
        ! Indices of downstream segment (O-indexed)
        integer(ip), intent(in) :: downstream_segment
        
        ! TODO check shape of upstream_segments

        ! (Re)allocate array of upstream segments
        if (allocated(seg%us_seg)) deallocate(seg%us_seg)
        allocate(seg%us_seg(size(upstream_segments)))
        seg%us_seg(:) = upstream_segments(:) + 1
        if (downstream_segment > -1) then
            seg%ds_seg = downstream_segment + 1
        else
            seg%ds_seg = downstream_segment
        end if
    
    end subroutine


    ! subroutine segment_finalise(seg)
    !     implicit none
    !     type(Segment), intent(inout) :: seg
        
    !     if (allocated(seg%us_seg)) deallocate(seg%us_seg)
        
    ! end subroutine


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Deallocation of mesh structure
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!
    !> Deallocation of mesh structure
    !! \param[inout] mesh Mesh structure.
    subroutine dealloc_mesh( msh )

        implicit none
        !> Mesh
        type(Mesh), intent(inout) :: msh
        
        ! Index of segment
        integer(ip) :: iseg


        if (allocated(msh%cs)) deallocate(msh%cs)
        if (allocated(msh%seg)) then
            do iseg = 1, size(msh%seg)
                call segment_finalise(msh%seg(iseg))
            end do
            deallocate(msh%seg)
        end if

    end subroutine dealloc_mesh



!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Allocation of a mesh structure
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!
    !> Initialise a mesh
    !! \param[in,out] msh Instance of Mesh
    !! \param[in] ncs Number of cross-sections
    !! \param[in] nseg Number of segments
    subroutine mesh_initialise(msh, ncs, nseg)
        implicit none
        type(Mesh), intent(inout) :: msh
        integer, intent(in) :: ncs
        integer, intent(in), optional :: nseg
        
        ! Index of cross-section
        integer(ip) :: ics
        
        msh%has_ghost_cells = .false.
        allocate(msh%cs(ncs))
        msh%ncs = ncs
        if (present(nseg)) then
            allocate(msh%seg(nseg))
            msh%nseg = nseg
        end if
        
        do ics = 1, ncs
            msh%cs(ics)%ibase = ics
        end do

    end subroutine mesh_initialise


    !> Initialise a mesh
    !! \param[in,out] msh Instance of Mesh
    !! \param[in] ncs Number of cross-sections
    !! \param[in] nseg Number of segments
    subroutine mesh_finalise(msh)
        implicit none
        type(Mesh), intent(inout) :: msh

    end subroutine mesh_finalise


    !> Initialise a mesh
    !! \param[in,out] msh Instance of Mesh
    !! \param[in] ncs Number of cross-sections
    !! \param[in] nseg Number of segments
    subroutine mesh_copy(src, dst)
        implicit none
        type(Mesh), intent(in) :: src
        type(Mesh), intent(inout) :: dst

        integer(ip) :: ics
        integer(ip) :: iseg

        call mesh_finalise(dst)

        dst%ncs = src%ncs
        dst%nseg = src%nseg
        dst%has_ghost_cells = src%has_ghost_cells
        dst%strickler_type_code = src%strickler_type_code

        ! Copy cross-sections
        allocate(dst%cs(size(src%cs)))
        do ics = 1, size(src%cs)
            call crosssection_copy(src%cs(ics), dst%cs(ics))
        end do

        ! Copy segments
        allocate(dst%seg(size(src%seg)))
        do iseg = 1, size(src%seg)
            call segment_copy(src%seg(iseg), dst%seg(iseg))
        end do

    end subroutine mesh_copy
    
    
    subroutine mesh_check(msh)
        implicit none
        type(Mesh), intent(in) :: msh
        
        integer(ip) :: ics
        integer(ip) :: ilevel
        character(len=32) :: tmp
        character(len=128) :: msg
        
        ! Check sizes
        if (msh%ncs /= size(msh%cs)) call abort_solver("msh%ncs not equal to size(msh%cs)")
        ! TODO
        
        ! Check cross-sections are initialised
        do ics = 1, msh%ncs
            if (.not. allocated(msh%cs(ics)%level_heights)) then
                write(tmp, '(I32)') ics
                write(msg, '(3A)') "msh%cs(", trim(adjustl(tmp)), ") not allocated"
                call abort_solver(trim(msg))
            end if
        end do
        
        ! Check with and heights
        do ics = 1, msh%ncs
            do ilevel = 2, size(msh%cs(ics)%level_heights)
                if (msh%cs(ics)%level_heights(ilevel-1) > msh%cs(ics)%level_heights(ilevel) + 0.00001) then
                    if (msh%cs(ics)%ibase > 0) then
                        write(tmp, '(I32)') msh%cs(ics)%ibase
                        write(msg, '(3A)') "Cross-section (", trim(adjustl(tmp)), "): heights are not in increasing order"
                    else
                        write(tmp, '(I32)') ics
                        write(msg, '(3A)') "Internal cross-section (", trim(adjustl(tmp)), "): heights are not in increasing order"
                    end if
                    call abort_solver(trim(msg))
                end if
                if (msh%cs(ics)%level_widths(ilevel-1) > msh%cs(ics)%level_widths(ilevel) + 0.001) then
                    print *, ics, ilevel
                    print *, msh%cs(ics)%level_widths(ilevel-1), msh%cs(ics)%level_widths(ilevel)
                    if (msh%cs(ics)%ibase > 0) then
                        write(tmp, '(I32)') msh%cs(ics)%ibase
                        write(msg, '(3A)') "Cross-section (", trim(adjustl(tmp)), "): widths are not in increasing order"
                    else
                        write(tmp, '(I32)') ics
                        write(msg, '(3A)') "Internal cross-section (", trim(adjustl(tmp)), "): widths are not in increasing order"
                    end if
                    call abort_solver(trim(msg))
                end if
            end do
        end do
        
    end subroutine


    subroutine setup_segment(msh, iseg, first_cs, ncs, us_seg, ds_seg)
        implicit none
        type(Mesh), intent(inout) :: msh
        integer(ip), intent(in) :: iseg
        integer(ip), intent(in) :: first_cs
        integer(ip), intent(in) :: ncs
        integer(ip), dimension(:), intent(in) :: us_seg
        integer(ip), intent(in) :: ds_seg
        
        ! Iterator
        integer(ip) :: i
        ! Number of boundary conditions
        integer(ip) :: nbc
        
        msh%seg(iseg+1)%first_cs = first_cs + 1
        msh%seg(iseg+1)%last_cs = first_cs + ncs
        if (allocated(msh%seg(iseg+1)%us_seg)) deallocate(msh%seg(iseg+1)%us_seg)
        allocate(msh%seg(iseg+1)%us_seg(size(us_seg)))
        nbc = 0
        do i = 1, size(us_seg)
            if (us_seg(i) <= -1) then
                msh%seg(iseg+1)%us_seg(i) = 0
                nbc = nbc + 1
                msh%seg(iseg+1)%us_bc = nbc
            else
                msh%seg(iseg+1)%us_seg(i) = us_seg(i) + 1
            end if
        end do
        if (ds_seg <= -1) then
            msh%seg(iseg+1)%ds_seg = 0
            nbc = nbc + 1
            msh%seg(iseg+1)%ds_bc = nbc
        else
            msh%seg(iseg+1)%ds_seg = ds_seg + 1
        end if
        
    end subroutine


    subroutine setup_crosssection(msh, ics, nlevels)
        implicit none
        type(Mesh), intent(inout) :: msh
        integer(ip), intent(in) :: ics
        integer(ip), intent(in) :: nlevels
        
        call crosssection_initialise(msh%cs(ics), nlevels)
        
    end subroutine


    subroutine update_geometries(msh)
        implicit none
        type(Mesh), intent(inout) :: msh
        
        ! Index of cross-section
        integer(ip) :: ics
        
        do ics = 1, msh%ncs
            call update_geometry(msh%cs(ics))
        end do
        
    end subroutine
    
    
    ! TODO implement unit_testing of this method
    subroutine add_ghost_cells(msh)
        implicit none
        type(Mesh), intent(inout) :: msh
        real(rp) :: dxs
        
        ! Index of cross-section
        integer(ip) :: ics
        ! Index of segment cross-section
        integer(ip) :: ics_seg
        ! Index of segment
        integer(ip) :: iseg
        ! New index of segment first cross-section
        integer(ip) :: new_first_cs
        ! New index of segment last cross-section
        integer(ip) :: new_last_cs
        ! Temporary cross-sections
        type(CrossSection), dimension(:), allocatable :: cs

        ! CHECK-UP
        if (.not. allocated(msh%cs)) then
            call f90wrap_abort("Mesh has no cross-sections")
        end if
        if (.not. allocated(msh%seg)) then
            call f90wrap_abort("Mesh has no segments")
        end if
        if (msh%has_ghost_cells) then
            call f90wrap_abort("Mesh already has ghost cells")
        end if
    
        ! Store existing cross-sections
        allocate(cs(size(msh%cs)))
        do ics = 1, size(msh%cs)
            call crosssection_copy(msh%cs(ics), cs(ics))
        end do

        ! Compute the total number of cross-sections
        msh%ncs = size(cs) + 4 * size(msh%seg)
        
        ! Reallocate array of cross-sections
        deallocate(msh%cs)
        allocate(msh%cs(msh%ncs))
        
        ics = 1
        do iseg = 1, size(msh%seg)
            
            ! Setup upstream ghost cells
            call crosssection_copy(cs(msh%seg(iseg)%first_cs), msh%cs(ics))
            msh%cs(ics)%ibase = 0
            call crosssection_copy(cs(msh%seg(iseg)%first_cs), msh%cs(ics+1))
            msh%cs(ics+1)%ibase = 0
            ics = ics + 2
            new_first_cs = ics
            
            ! Restore interior cells
            do ics_seg = msh%seg(iseg)%first_cs, msh%seg(iseg)%last_cs
                call crosssection_copy(cs(ics_seg), msh%cs(ics))
                ics = ics + 1
            end do
            new_last_cs = ics - 1

            ! Setup downstream ghost cells
            call crosssection_copy(cs(msh%seg(iseg)%last_cs), msh%cs(ics))
            msh%cs(ics)%ibase = 0
            call crosssection_copy(cs(msh%seg(iseg)%last_cs), msh%cs(ics+1))
            msh%cs(ics+1)%ibase = 0
            ics = ics + 2
            
            ! Update first and last cross-section for current segment
            msh%seg(iseg)%first_cs = new_first_cs
            msh%seg(iseg)%last_cs = new_last_cs
            
        end do
        
        deallocate(cs)
        
        msh%has_ghost_cells = .true.
        
    end subroutine
    
    
    subroutine resample(msh, dxs)
        implicit none
        type(Mesh), intent(inout) :: msh
        real(rp) :: dxs
        
        call resample_mesh(msh, dxs)
        
    end subroutine
    
    
    subroutine set_strickler_type(msh, strickler_type)
        implicit none
        type(Mesh), intent(inout) :: msh
        character(len=*), intent(in) :: strickler_type
        
        if (strickler_type == "constant") then
        
            msh%strickler_type_code = strickler_type_constant

        else if (strickler_type == "powerlaw_h") then
        
            msh%strickler_type_code = strickler_type_powerlaw_h
            
        else if (strickler_type == "Einstein") then
        
! TODO: Deprecate Einstein model
!             call f90wrap_abort("Einstein model is deprecated (use 'average_conveyance')")
#ifdef STRICKLER_EINSTEIN
            msh%strickler_type_code = strickler_type_einstein
#else
            call f90wrap_abort("DassFlow-1D was compiled without the Einstein model")
#endif
        else if (strickler_type == "average_conveyance") then
#ifdef AVERAGE_CONVEYANCE
        
            msh%strickler_type_code = strickler_type_average_conveyance
#else
            call f90wrap_abort("DassFlow-1D was compiled without the average-conveyance model")
#endif
        else if (strickler_type == "Debord") then
        
#ifdef DEBORD_FORMULA
            msh%strickler_type_code = strickler_type_debord
#else
            call f90wrap_abort("DassFlow-1D was compiled without the Debord formula")
#endif
        else
        
            call abort_solver("Wrong Strickler type: "//strickler_type)
        
        end if
        msh%strickler_type = strickler_type
        msh%cs(:)%strickler_type_code = msh%strickler_type_code
    
    end subroutine


    subroutine set_uniform_strickler_parameters(msh, strickler_params)
        implicit none
        type(Mesh), intent(inout) :: msh
        real(rp), dimension(:), intent(in) :: strickler_params
        ! Index of cross-section
        integer(ip) :: ics
        
        ! Check sizes
        if (msh%strickler_type_code == strickler_type_constant) then
            if(size(strickler_params) /= 1) then
                call abort_solver("Shape of strickler_params must be (1) for K=constant")
            end if
        else if (msh%strickler_type_code == strickler_type_powerlaw_h) then
            if(size(strickler_params) /= 2) then
                call abort_solver("Shape of strickler_params must be (2) for K=powerlaw(h)")
            end if
#ifdef STRICKLER_EINSTEIN
        else if (msh%strickler_type_code == strickler_type_einstein) then
            if(size(strickler_params) /= 3) then
                call abort_solver("Shape of strickler_params must be (3) for Einstein formula")
            end if
#endif
#ifdef AVERAGE_CONVEYANCE
        else if (msh%strickler_type_code == strickler_type_average_conveyance) then
            if(size(strickler_params) /= 3) then
                call abort_solver("Shape of strickler_params must be (3) for average conveyance model")
            end if
#endif
#ifdef DEBORD_FORMULA
        else if (msh%strickler_type_code == strickler_type_debord) then
            if(size(strickler_params) /= 3) then
                call abort_solver("Shape of strickler_params must be (3) for Debord model")
            end if
#endif
        end if
        
        do ics = 1, msh%ncs
            msh%cs(ics)%strickler_params(1:size(strickler_params)) = strickler_params(:)
        end do
        
    end subroutine


    subroutine set_pointwise_spatial_field(msh, iseg, field, data)
        implicit none
        !> Mesh
        type(Mesh), intent(in) :: msh
        ! Index of segment
        integer(ip), intent(in) :: iseg
        ! Spatial field
        type(SpatialField), intent(inout) :: field
        ! Array of field data
        real(rp), dimension(:), intent(in) :: data
        
        ! Iterator
        integer(ip) :: i
        ! Index of cross-section
        integer(ip) :: ics
        ! Number of cross-sections
        integer(ip) :: ncs
        
        
        ! CHECK-UP
        ncs = msh%seg(iseg)%last_cs - msh%seg(iseg)%first_cs + 1
        if(size(data) /= ncs) then
            call abort_solver("data must be of size the number of cross-sections for current segment")
        end if
        
        ! Set interpolation to 'pt'
        field%interp = "pt"
        
        ! (Re)allocate field arrays
        if (allocated(field%x)) deallocate(field%x)
        if (allocated(field%y)) deallocate(field%y)
        allocate(field%y(ncs))
        
        ! Copy data
        field%y(:) = data(:)
        
    end subroutine


    subroutine set_piecewise_uniform_spatial_field(msh, iseg, field, x, y)
        implicit none
        !> Mesh
        type(Mesh), intent(in) :: msh
        ! Index of segment
        integer(ip), intent(in) :: iseg
        ! Spatial field
        type(SpatialField), intent(inout) :: field
        ! Array of curvilinear abscissae
        real(rp), dimension(:), intent(in) :: x
        ! Array of field values
        real(rp), dimension(:), intent(in) :: y
        
        ! Iterator
        integer(ip) :: i
        ! Index of cross-section
        integer(ip) :: ics
        ! Number of cross-sections
        integer(ip) :: ncs
        
        
        ! CHECK-UP
        if(size(y) /= size(x)) then
            call abort_solver("x and y must be of same size")
        end if
        
        ! Set interpolation to 'linear'
        field%interp = "p0"
        
        ! (Re)allocate field arrays
        if (allocated(field%x)) deallocate(field%x)
        allocate(field%x(size(x)))
        if (allocated(field%y)) deallocate(field%y)
        allocate(field%y(size(x)))
        
        ! Copy data
        do i = 1, size(x)
            field%x(i) = x(size(x)-i+1)
            field%y(i) = y(size(x)-i+1)
        end do
        
    end subroutine


    subroutine set_piecewise_linear_spatial_field(msh, iseg, field, x, y)
        implicit none
        !> Mesh
        type(Mesh), intent(in) :: msh
        ! Index of segment
        integer(ip), intent(in) :: iseg
        ! Spatial field
        type(SpatialField), intent(inout) :: field
        ! Array of curvilinear abscissae
        real(rp), dimension(:), intent(in) :: x
        ! Array of field values
        real(rp), dimension(:), intent(in) :: y
        
        ! Iterator
        integer(ip) :: i
        ! Index of cross-section
        integer(ip) :: ics
        ! Number of cross-sections
        integer(ip) :: ncs
        
        
        ! CHECK-UP
        if(size(y) /= size(x)) then
            call abort_solver("x and y must be of same size")
        end if
        
        ! Set interpolation to 'linear'
        field%interp = "linear"
        
        ! (Re)allocate field arrays
        if (allocated(field%x)) deallocate(field%x)
        allocate(field%x(size(x)))
        if (allocated(field%y)) deallocate(field%y)
        allocate(field%y(size(x)))
        
        ! Copy data
        do i = 1, size(x)
            field%x(i) = x(size(x)-i+1)
            field%y(i) = y(size(x)-i+1)
        end do
!         field%x(:) = x(:)
!         field%y(:) = y(:)
        
    end subroutine


    subroutine set_bathymetry_spatial_field(msh, iseg, x, bathy, interp, eps)
        implicit none
        type(Mesh), intent(inout) :: msh
        integer(ip),intent(in):: iseg
        real(rp), dimension(:), intent(in) :: x
        real(rp), dimension(:), intent(in) :: bathy
        character(len=*), intent(in) :: interp
        real(rp), intent(in) :: eps
        ! True if x are in decreasing order
        logical :: x_decreasing
        real(rp), dimension(size(x)) :: tmp
        
!         ! Index of cross-section
!         integer(ip) :: ics
        
        ! CHECK-UP
        if(iseg+1 < 1 .or. iseg+1 > size(msh%seg)) then
            call abort_solver("Wrong segment index")
        end if
        if(interp /= "linear") then
            call abort_solver("'interp' must be 'linear'")
        end if
        
        if (allocated(msh%seg(iseg+1)%bathy_field%x)) deallocate(msh%seg(iseg+1)%bathy_field%x)
        if (allocated(msh%seg(iseg+1)%bathy_field%y)) deallocate(msh%seg(iseg+1)%bathy_field%y)
        allocate(msh%seg(iseg+1)%bathy_field%x(size(x)))
        allocate(msh%seg(iseg+1)%bathy_field%y(size(x)))
        msh%seg(iseg+1)%bathy_field%interp = interp
        ! Store data with x in increasing order
        if (x(size(x)) < x(1)) then
            msh%seg(iseg+1)%bathy_field%x(:) = x(size(x):1:-1)
            msh%seg(iseg+1)%bathy_field%y(:) = bathy(size(x):1:-1)
        else
            msh%seg(iseg+1)%bathy_field%x(:) = x(:)
            msh%seg(iseg+1)%bathy_field%y(:) = bathy(:)
        end if
        
        call apply_bathy_field(msh, eps)
        
    end subroutine

    ! DEPRECATED
!     subroutine set_bathy_field_linear(msh, x, bathy)
!         implicit none
!         type(Mesh), intent(inout) :: msh
!         real(rp), dimension(:), intent(in) :: x
!         real(rp), dimension(:), intent(in) :: bathy
!         
!         ! Index of cross-section
!         integer(ip) :: ics
!         
!         
!         ! TODO check x and bathy are of same size
!         
!         if (allocated(msh%bathy_field%x)) deallocate(msh%bathy_field%x)
!         if (allocated(msh%bathy_field%y)) deallocate(msh%bathy_field%y)
!         allocate(msh%bathy_field%x(size(x)))
!         allocate(msh%bathy_field%y(size(x)))
!         msh%bathy_field%interp = "linear"
!         msh%bathy_field%x(:) = x(:)
!         msh%bathy_field%y(:) = bathy(:)
!         
!     end subroutine


    subroutine set_strickler_spatial_fields(msh, iseg, x, strickler_params, interp)
        implicit none
        type(Mesh), intent(inout) :: msh
        integer(ip), intent(in):: iseg
        real(rp), dimension(:), intent(in) :: x
        real(rp), dimension(:, :), intent(in) :: strickler_params
        character(len=*), intent(in) :: interp
        
        ! Iterator
        integer(ip) :: i
        ! Index of cross-section
        integer(ip) :: ics
        
        
        ! CHECK-UP
        if(iseg+1 < 1 .or. iseg+1 > size(msh%seg)) then
            call abort_solver("Wrong segment index")
        end if
        if(interp /= "constant" .and. interp /= "p0" .and. interp /= "linear" ) then
            call abort_solver("'interp' must be 'constant', 'p0' or 'linear'")
        end if

        if (msh%strickler_type_code == strickler_type_constant) then
            if(size(strickler_params, 1) /= 1) then
                call abort_solver("Shape of strickler_params must be (1,N) for K=constant")
            end if
        else if (msh%strickler_type_code == strickler_type_powerlaw_h) then
            if(size(strickler_params, 1) /= 2) then
                call abort_solver("Shape of strickler_params must be (2,N) for K=powerlaw(h)")
            end if
#ifdef STRICKLER_EINSTEIN
        else if (msh%strickler_type_code == strickler_type_einstein) then
            if(size(strickler_params, 1) /= 3) then
                call abort_solver("Shape of strickler_params must be (3,N) for Einstein formula")
            end if
#endif
#ifdef AVERAGE_CONVEYANCE
        else if (msh%strickler_type_code == strickler_type_average_conveyance) then
            if(size(strickler_params, 1) /= 3) then
                call abort_solver("Shape of strickler_params must be (3,N) for Average Conveyance formula")
            end if
#endif
#ifdef DEBORD_FORMULA
        else if (msh%strickler_type_code == strickler_type_einstein) then
            if(size(strickler_params, 1) /= 3) then
                call abort_solver("Shape of strickler_params must be (3,N) for Debord formula")
            end if
#endif
        else
            call abort_solver("Wrong strickler type for mesh: "//trim(msh%strickler_type))
        end if
        if(size(strickler_params, 2) /= size(x)) then
            call abort_solver("Shape of strickler_params must be (:,N) where N=size(x)")
        end if
        
        if (allocated(msh%seg(iseg+1)%strickler_fields)) then
            do i = 1, size(msh%seg(iseg+1)%strickler_fields)
                if (allocated(msh%seg(iseg+1)%strickler_fields(i)%x)) deallocate(msh%seg(iseg+1)%strickler_fields(i)%x)
                if (allocated(msh%seg(iseg+1)%strickler_fields(i)%y)) deallocate(msh%seg(iseg+1)%strickler_fields(i)%y)
            end do
            deallocate(msh%seg(iseg+1)%strickler_fields)
        end if
        if (msh%strickler_type_code == strickler_type_constant) then
            allocate(msh%seg(iseg+1)%strickler_fields(1))
            allocate(msh%seg(iseg+1)%strickler_fields(1)%x(size(x)))
            allocate(msh%seg(iseg+1)%strickler_fields(1)%y(size(strickler_params, 2)))
            msh%seg(iseg+1)%strickler_fields(1)%interp = interp
            msh%seg(iseg+1)%strickler_fields(1)%x(:) = x(:)
            msh%seg(iseg+1)%strickler_fields(1)%y(:) = strickler_params(1, :)
        else if (msh%strickler_type_code == strickler_type_powerlaw_h) then
            allocate(msh%seg(iseg+1)%strickler_fields(2))
            allocate(msh%seg(iseg+1)%strickler_fields(1)%x(size(x)))
            allocate(msh%seg(iseg+1)%strickler_fields(1)%y(size(strickler_params, 2)))
            allocate(msh%seg(iseg+1)%strickler_fields(2)%x(size(x)))
            allocate(msh%seg(iseg+1)%strickler_fields(2)%y(size(strickler_params, 2)))
            msh%seg(iseg+1)%strickler_fields(1)%interp = interp
            if (x(size(x)) < x(1)) then
                msh%seg(iseg+1)%strickler_fields(1)%x(:) = x(size(x):1:-1)
                msh%seg(iseg+1)%strickler_fields(1)%y(:) = strickler_params(1, size(x):1:-1)
                msh%seg(iseg+1)%strickler_fields(2)%interp = interp
                msh%seg(iseg+1)%strickler_fields(2)%x(:) = x(size(x):1:-1)
                msh%seg(iseg+1)%strickler_fields(2)%y(:) = strickler_params(2, size(x):1:-1)
            else
                msh%seg(iseg+1)%strickler_fields(1)%x(:) = x(:)
                msh%seg(iseg+1)%strickler_fields(1)%y(:) = strickler_params(1, :)
                msh%seg(iseg+1)%strickler_fields(2)%interp = interp
                msh%seg(iseg+1)%strickler_fields(2)%x(:) = x(:)
                msh%seg(iseg+1)%strickler_fields(2)%y(:) = strickler_params(2, :)
            end if
#ifdef STRICKLER_EINSTEIN
        else if (msh%strickler_type_code == strickler_type_einstein) then
            allocate(msh%seg(iseg+1)%strickler_fields(3))
            allocate(msh%seg(iseg+1)%strickler_fields(1)%x(size(x)))
            allocate(msh%seg(iseg+1)%strickler_fields(1)%y(size(strickler_params, 2)))
            allocate(msh%seg(iseg+1)%strickler_fields(2)%x(size(x)))
            allocate(msh%seg(iseg+1)%strickler_fields(2)%y(size(strickler_params, 2)))
            allocate(msh%seg(iseg+1)%strickler_fields(3)%x(size(x)))
            allocate(msh%seg(iseg+1)%strickler_fields(3)%y(size(strickler_params, 2)))
            msh%seg(iseg+1)%strickler_fields(1)%interp = interp
            if (x(size(x)) < x(1)) then
                msh%seg(iseg+1)%strickler_fields(1)%x(:) = x(size(x):1:-1)
                msh%seg(iseg+1)%strickler_fields(1)%y(size(x):1:-1) = strickler_params(1, size(x):1:-1)
                msh%seg(iseg+1)%strickler_fields(2)%interp = interp
                msh%seg(iseg+1)%strickler_fields(2)%x(size(x):1:-1) = x(size(x):1:-1)
                msh%seg(iseg+1)%strickler_fields(2)%y(size(x):1:-1) = strickler_params(2, size(x):1:-1)
                msh%seg(iseg+1)%strickler_fields(2)%interp = interp
                msh%seg(iseg+1)%strickler_fields(3)%x(size(x):1:-1) = x(size(x):1:-1)
                msh%seg(iseg+1)%strickler_fields(3)%y(size(x):1:-1) = strickler_params(3, size(x):1:-1)
            else
                msh%seg(iseg+1)%strickler_fields(1)%x(:) = x(:)
                msh%seg(iseg+1)%strickler_fields(1)%y(:) = strickler_params(1, :)
                msh%seg(iseg+1)%strickler_fields(2)%interp = interp
                msh%seg(iseg+1)%strickler_fields(2)%x(:) = x(:)
                msh%seg(iseg+1)%strickler_fields(2)%y(:) = strickler_params(2, :)
                msh%seg(iseg+1)%strickler_fields(2)%interp = interp
                msh%seg(iseg+1)%strickler_fields(3)%x(:) = x(:)
                msh%seg(iseg+1)%strickler_fields(3)%y(:) = strickler_params(3, :)
            end if
#endif
#ifdef AVERAGE_CONVEYANCE
        else if (msh%strickler_type_code == strickler_type_average_conveyance) then
            allocate(msh%seg(iseg+1)%strickler_fields(3))
            allocate(msh%seg(iseg+1)%strickler_fields(1)%x(size(x)))
            allocate(msh%seg(iseg+1)%strickler_fields(1)%y(size(strickler_params, 2)))
            allocate(msh%seg(iseg+1)%strickler_fields(2)%x(size(x)))
            allocate(msh%seg(iseg+1)%strickler_fields(2)%y(size(strickler_params, 2)))
            allocate(msh%seg(iseg+1)%strickler_fields(3)%x(size(x)))
            allocate(msh%seg(iseg+1)%strickler_fields(3)%y(size(strickler_params, 2)))
            msh%seg(iseg+1)%strickler_fields(1)%interp = interp
            if (x(size(x)) < x(1)) then
                msh%seg(iseg+1)%strickler_fields(1)%x(:) = x(size(x):1:-1)
                msh%seg(iseg+1)%strickler_fields(1)%y(size(x):1:-1) = strickler_params(1, size(x):1:-1)
                msh%seg(iseg+1)%strickler_fields(2)%interp = interp
                msh%seg(iseg+1)%strickler_fields(2)%x(size(x):1:-1) = x(size(x):1:-1)
                msh%seg(iseg+1)%strickler_fields(2)%y(size(x):1:-1) = strickler_params(2, size(x):1:-1)
                msh%seg(iseg+1)%strickler_fields(2)%interp = interp
                msh%seg(iseg+1)%strickler_fields(3)%x(size(x):1:-1) = x(size(x):1:-1)
                msh%seg(iseg+1)%strickler_fields(3)%y(size(x):1:-1) = strickler_params(3, size(x):1:-1)
            else
                msh%seg(iseg+1)%strickler_fields(1)%x(:) = x(:)
                msh%seg(iseg+1)%strickler_fields(1)%y(:) = strickler_params(1, :)
                msh%seg(iseg+1)%strickler_fields(2)%interp = interp
                msh%seg(iseg+1)%strickler_fields(2)%x(:) = x(:)
                msh%seg(iseg+1)%strickler_fields(2)%y(:) = strickler_params(2, :)
                msh%seg(iseg+1)%strickler_fields(2)%interp = interp
                msh%seg(iseg+1)%strickler_fields(3)%x(:) = x(:)
                msh%seg(iseg+1)%strickler_fields(3)%y(:) = strickler_params(3, :)
            end if
#endif
#ifdef DEBORD_FORMULA
        else if (msh%strickler_type_code == strickler_type_debord) then
            allocate(msh%seg(iseg+1)%strickler_fields(3))
            allocate(msh%seg(iseg+1)%strickler_fields(1)%x(size(x)))
            allocate(msh%seg(iseg+1)%strickler_fields(1)%y(size(strickler_params, 2)))
            allocate(msh%seg(iseg+1)%strickler_fields(2)%x(size(x)))
            allocate(msh%seg(iseg+1)%strickler_fields(2)%y(size(strickler_params, 2)))
            allocate(msh%seg(iseg+1)%strickler_fields(3)%x(size(x)))
            allocate(msh%seg(iseg+1)%strickler_fields(3)%y(size(strickler_params, 2)))
            msh%seg(iseg+1)%strickler_fields(1)%interp = interp
            if (x(size(x)) < x(1)) then
                msh%seg(iseg+1)%strickler_fields(1)%x(:) = x(size(x):1:-1)
                msh%seg(iseg+1)%strickler_fields(1)%y(size(x):1:-1) = strickler_params(1, size(x):1:-1)
                msh%seg(iseg+1)%strickler_fields(2)%interp = interp
                msh%seg(iseg+1)%strickler_fields(2)%x(size(x):1:-1) = x(size(x):1:-1)
                msh%seg(iseg+1)%strickler_fields(2)%y(size(x):1:-1) = strickler_params(2, size(x):1:-1)
                msh%seg(iseg+1)%strickler_fields(2)%interp = interp
                msh%seg(iseg+1)%strickler_fields(3)%x(size(x):1:-1) = x(size(x):1:-1)
                msh%seg(iseg+1)%strickler_fields(3)%y(size(x):1:-1) = strickler_params(3, size(x):1:-1)
            else
                msh%seg(iseg+1)%strickler_fields(1)%x(:) = x(:)
                msh%seg(iseg+1)%strickler_fields(1)%y(:) = strickler_params(1, :)
                msh%seg(iseg+1)%strickler_fields(2)%interp = interp
                msh%seg(iseg+1)%strickler_fields(2)%x(:) = x(:)
                msh%seg(iseg+1)%strickler_fields(2)%y(:) = strickler_params(2, :)
                msh%seg(iseg+1)%strickler_fields(2)%interp = interp
                msh%seg(iseg+1)%strickler_fields(3)%x(:) = x(:)
                msh%seg(iseg+1)%strickler_fields(3)%y(:) = strickler_params(3, :)
            end if
#endif
        end if
        call apply_strickler_fields(msh)
    end subroutine


    subroutine set_strickler_fields_segment(msh, strickler_params)
        implicit none
        type(Mesh), intent(inout) :: msh
        real(rp), dimension(:, :), intent(in) :: strickler_params
        ! Index of segment
        integer(ip):: iseg
        ! Iterator
        integer(ip) :: i
        ! Index of cross-section
        integer(ip) :: ics
        
        ! TODO check sizes
        if (msh%strickler_type_code == strickler_type_constant) then
            if(size(strickler_params, 1) /= 1) then
                call abort_solver("Shape of strickler_params must be (1,N) for K=constant")
            end if
        else if (msh%strickler_type_code == strickler_type_powerlaw_h) then
            if(size(strickler_params, 1) /= 2) then
                call abort_solver("Shape of strickler_params must be (2,N) for K=powerlaw(h)")
            end if
#ifdef STRICKLER_EINSTEIN
        else if (msh%strickler_type_code == strickler_type_einstein) then
            if(size(strickler_params, 1) /= 3) then
                call abort_solver("Shape of strickler_params must be (3,N) for Einstein formula")
            end if
#endif
#ifdef AVERAGE_CONVEYANCE
        else if (msh%strickler_type_code == strickler_type_average_conveyance) then
            if(size(strickler_params, 1) /= 3) then
                call abort_solver("Shape of strickler_params must be (3,N) for 'average_conveyance' model")
            end if
#endif
#ifdef DEBORD_FORMULA
        else if (msh%strickler_type_code == strickler_type_debord) then
            if(size(strickler_params, 1) /= 3) then
                call abort_solver("Shape of strickler_params must be (3,N) for Debord formula")
            end if
#endif
        else
            call abort_solver("Wrong strickler type for mesh: "//trim(msh%strickler_type))
        end if
        if(size(strickler_params, 2) /= msh%nseg) then
            call abort_solver("Shape of strickler_params must be (:,N) where N is the number of segments")
        end if

        do iseg = 1, msh%nseg

            if (allocated(msh%seg(iseg)%strickler_fields)) then
                do i = 1, size(msh%seg(iseg)%strickler_fields)
                    if (allocated(msh%seg(iseg)%strickler_fields(i)%x)) deallocate(msh%seg(iseg)%strickler_fields(i)%x)
                    if (allocated(msh%seg(iseg)%strickler_fields(i)%y)) deallocate(msh%seg(iseg)%strickler_fields(i)%y)
                end do
                deallocate(msh%seg(iseg)%strickler_fields)
            end if
	
            if (msh%strickler_type_code == strickler_type_constant) then
                allocate(msh%seg(iseg)%strickler_fields(1))
                allocate(msh%seg(iseg)%strickler_fields(1)%x(1))
                allocate(msh%seg(iseg)%strickler_fields(1)%y(1))
                msh%seg(iseg)%strickler_fields(1)%interp = "segment"
                msh%seg(iseg)%strickler_fields(1)%y(:) = strickler_params(1,iseg)
            else if (msh%strickler_type_code == strickler_type_powerlaw_h) then
                allocate(msh%seg(iseg)%strickler_fields(2))
                allocate(msh%seg(iseg)%strickler_fields(1)%x(1))
                allocate(msh%seg(iseg)%strickler_fields(1)%y(1))
                allocate(msh%seg(iseg)%strickler_fields(2)%x(1))
                allocate(msh%seg(iseg)%strickler_fields(2)%y(1))
                msh%seg(iseg)%strickler_fields(1)%interp = "segment"
                msh%seg(iseg)%strickler_fields(1)%y(:) = strickler_params(1, iseg)
                msh%seg(iseg)%strickler_fields(2)%interp = "segment"
                msh%seg(iseg)%strickler_fields(2)%y(:) = strickler_params(2, iseg)
#if defined(STRICKLER_EINSTEIN) || defined(AVERAGE_CONVEYANCE) || defined(DEBORD_FORMULA)
            else if (msh%strickler_type_code == strickler_type_einstein .or. &
                     msh%strickler_type_code == strickler_type_average_conveyance .or. &
                     msh%strickler_type_code == strickler_type_debord) then
                allocate(msh%seg(iseg)%strickler_fields(3))
                allocate(msh%seg(iseg)%strickler_fields(1)%x(1))
                allocate(msh%seg(iseg)%strickler_fields(1)%y(1))
                allocate(msh%seg(iseg)%strickler_fields(2)%x(1))
                allocate(msh%seg(iseg)%strickler_fields(2)%y(1))
                allocate(msh%seg(iseg)%strickler_fields(3)%x(1))
                allocate(msh%seg(iseg)%strickler_fields(3)%y(1))
                msh%seg(iseg)%strickler_fields(1)%interp = "segment"
                msh%seg(iseg)%strickler_fields(1)%y(:) = strickler_params(1, iseg)
                msh%seg(iseg)%strickler_fields(2)%interp = "segment"
                msh%seg(iseg)%strickler_fields(2)%y(:) = strickler_params(2, iseg)
                msh%seg(iseg)%strickler_fields(3)%interp = "segment"
                msh%seg(iseg)%strickler_fields(3)%y(:) = strickler_params(3, iseg)
#endif
            end if

	end do
        
        call apply_strickler_fields(msh)
        
    end subroutine


    subroutine set_strickler_fields_linear(msh, x, strickler_params, iseg)
        implicit none
        type(Mesh), intent(inout) :: msh
        real(rp), dimension(:), intent(in) :: x
        real(rp), dimension(:, :), intent(in) :: strickler_params
        ! Index of segment
        integer(ip),intent(in):: iseg
        
        ! Iterator
        integer(ip) :: i
        ! Index of cross-section
        integer(ip) :: ics
        
        
        ! TODO check sizes
        if (msh%strickler_type_code == strickler_type_constant) then
            if(size(strickler_params, 1) /= 1) then
                call abort_solver("Shape of strickler_params must be (1,N) for K=constant")
            end if
            if(size(strickler_params, 2) /= size(x)) then
                call abort_solver("Shape of strickler_params must be (1,N) where N=size(x)")
            end if
        else if (msh%strickler_type_code == strickler_type_powerlaw_h) then
            if(size(strickler_params, 1) /= 2) then
                call abort_solver("Shape of strickler_params must be (2,N) for K=powerlaw(h)")
            end if
        else
            call abort_solver("Wrong strickler type for mesh: "//trim(msh%strickler_type))
        end if
        if(size(strickler_params, 2) /= size(x)) then
            call abort_solver("Shape of strickler_params must be (:,N) where N=size(x)")
        end if
        
        if (allocated(msh%seg(iseg)%strickler_fields)) then
            do i = 1, size(msh%seg(iseg)%strickler_fields)
                if (allocated(msh%seg(iseg)%strickler_fields(i)%x)) deallocate(msh%seg(iseg)%strickler_fields(i)%x)
                if (allocated(msh%seg(iseg)%strickler_fields(i)%y)) deallocate(msh%seg(iseg)%strickler_fields(i)%y)
            end do
            deallocate(msh%seg(iseg)%strickler_fields)
        end if
        if (msh%strickler_type_code == strickler_type_constant) then
            allocate(msh%seg(iseg)%strickler_fields(1))
            allocate(msh%seg(iseg)%strickler_fields(1)%x(size(x)))
            allocate(msh%seg(iseg)%strickler_fields(1)%y(size(strickler_params, 2)))
            msh%seg(iseg)%strickler_fields(1)%interp = "linear"
            msh%seg(iseg)%strickler_fields(1)%x(:) = x(:)
            msh%seg(iseg)%strickler_fields(1)%y(:) = strickler_params(1, :)
        else if (msh%strickler_type_code == strickler_type_powerlaw_h) then
            allocate(msh%seg(iseg)%strickler_fields(2))
            allocate(msh%seg(iseg)%strickler_fields(1)%x(size(x)))
            allocate(msh%seg(iseg)%strickler_fields(1)%y(size(strickler_params, 2)))
            allocate(msh%seg(iseg)%strickler_fields(2)%x(size(x)))
            allocate(msh%seg(iseg)%strickler_fields(2)%y(size(strickler_params, 2)))
            msh%seg(iseg)%strickler_fields(1)%interp = "linear"
            msh%seg(iseg)%strickler_fields(1)%x(:) = x(:)
            msh%seg(iseg)%strickler_fields(1)%y(:) = strickler_params(1, :)
            msh%seg(iseg)%strickler_fields(2)%interp = "linear"
            msh%seg(iseg)%strickler_fields(2)%x(:) = x(:)
            msh%seg(iseg)%strickler_fields(2)%y(:) = strickler_params(2, :)
#ifdef STRICKLER_EINSTEIN
        else if (msh%strickler_type_code == strickler_type_einstein) then
            ! TODO
            call abort_solver("Not implemented for Einstein formula")
!             allocate(msh%strickler_fields(3))
!             allocate(msh%strickler_fields(1)%x(msh%nseg))
!             allocate(msh%strickler_fields(1)%y(msh%nseg))
!             allocate(msh%strickler_fields(2)%x(msh%nseg))
!             allocate(msh%strickler_fields(2)%y(msh%nseg))
!             allocate(msh%strickler_fields(3)%x(msh%nseg))
!             allocate(msh%strickler_fields(3)%y(msh%nseg))
!             msh%strickler_fields(1)%interp = "segment"
!             msh%strickler_fields(1)%y(:) = strickler_params(1, :)
!             msh%strickler_fields(2)%interp = "segment"
!             msh%strickler_fields(2)%y(:) = strickler_params(2, :)
!             msh%strickler_fields(3)%interp = "segment"
!             msh%strickler_fields(3)%y(:) = strickler_params(3, :)
#endif
#ifdef AVERAGE_CONVEYANCE
        else if (msh%strickler_type_code == strickler_type_average_conveyance) then
            ! TODO
            call abort_solver("Not implemented for 'average_conveyance' model")
!             allocate(msh%strickler_fields(3))
!             allocate(msh%strickler_fields(1)%x(msh%nseg))
!             allocate(msh%strickler_fields(1)%y(msh%nseg))
!             allocate(msh%strickler_fields(2)%x(msh%nseg))
!             allocate(msh%strickler_fields(2)%y(msh%nseg))
!             allocate(msh%strickler_fields(3)%x(msh%nseg))
!             allocate(msh%strickler_fields(3)%y(msh%nseg))
!             msh%strickler_fields(1)%interp = "segment"
!             msh%strickler_fields(1)%y(:) = strickler_params(1, :)
!             msh%strickler_fields(2)%interp = "segment"
!             msh%strickler_fields(2)%y(:) = strickler_params(2, :)
!             msh%strickler_fields(3)%interp = "segment"
!             msh%strickler_fields(3)%y(:) = strickler_params(3, :)
#endif
#ifdef DEBORD_FORMULA
        else if (msh%strickler_type_code == strickler_type_debord) then
            ! TODO
            call abort_solver("Not implemented for Debord formula")
#endif
        end if
        call apply_strickler_fields(msh)
    end subroutine


    subroutine set_strickler_fields_p0(msh, x, strickler_params,iseg)
        implicit none
        type(Mesh), intent(inout) :: msh
        real(rp), dimension(:), intent(in) :: x
        real(rp), dimension(:, :), intent(in) :: strickler_params
        ! Index of segment
        integer(ip),intent(in):: iseg
        
        ! Iterator
        integer(ip) :: i
        ! Index of cross-section
        integer(ip) :: ics
        
        
        ! TODO check sizes
        if (msh%strickler_type_code == strickler_type_constant) then
            if(size(strickler_params, 1) /= 1) then
                call abort_solver("Shape of strickler_params must be (1,N) for K=constant")
            end if
        else if (msh%strickler_type_code == strickler_type_powerlaw_h) then
            if(size(strickler_params, 1) /= 2) then
                call abort_solver("Shape of strickler_params must be (2,N) for K=powerlaw(h)")
            end if
        else
            call abort_solver("Wrong strickler type for mesh: "//trim(msh%strickler_type))
        end if
        if(size(strickler_params, 2) /= size(x)) then
            call abort_solver("Shape of strickler_params must be (:,N) where N=size(x)")
        end if
        
        if (allocated(msh%seg(iseg)%strickler_fields)) then
            do i = 1, size(msh%seg(iseg)%strickler_fields)
                if (allocated(msh%seg(iseg)%strickler_fields(i)%x)) deallocate(msh%seg(iseg)%strickler_fields(i)%x)
                if (allocated(msh%seg(iseg)%strickler_fields(i)%y)) deallocate(msh%seg(iseg)%strickler_fields(i)%y)
            end do
            deallocate(msh%seg(iseg)%strickler_fields)
        end if
        if (msh%strickler_type_code == strickler_type_constant) then
            allocate(msh%seg(iseg)%strickler_fields(1))
            allocate(msh%seg(iseg)%strickler_fields(1)%x(size(x)))
            allocate(msh%seg(iseg)%strickler_fields(1)%y(size(strickler_params, 2)))
            msh%seg(iseg)%strickler_fields(1)%interp = "p0"
            msh%seg(iseg)%strickler_fields(1)%x(:) = x(:)
            msh%seg(iseg)%strickler_fields(1)%y(:) = strickler_params(1, :)
        else if (msh%strickler_type_code == strickler_type_powerlaw_h) then
            allocate(msh%seg(iseg)%strickler_fields(2))
            allocate(msh%seg(iseg)%strickler_fields(1)%x(size(x)))
            allocate(msh%seg(iseg)%strickler_fields(1)%y(size(strickler_params, 2)))
            allocate(msh%seg(iseg)%strickler_fields(2)%x(size(x)))
            allocate(msh%seg(iseg)%strickler_fields(2)%y(size(strickler_params, 2)))
            msh%seg(iseg)%strickler_fields(1)%interp = "p0"
            msh%seg(iseg)%strickler_fields(1)%x(:) = x(:)
            msh%seg(iseg)%strickler_fields(1)%y(:) = strickler_params(1, :)
            msh%seg(iseg)%strickler_fields(2)%interp = "p0"
            msh%seg(iseg)%strickler_fields(2)%x(:) = x(:)
            msh%seg(iseg)%strickler_fields(2)%y(:) = strickler_params(2, :)
#ifdef STRICKLER_EINSTEIN
        else if (msh%strickler_type_code == strickler_type_einstein) then
            ! TODO
            call abort_solver("Not implemented for Einstein formula")
!             allocate(msh%strickler_fields(3))
!             allocate(msh%strickler_fields(1)%x(msh%nseg))
!             allocate(msh%strickler_fields(1)%y(msh%nseg))
!             allocate(msh%strickler_fields(2)%x(msh%nseg))
!             allocate(msh%strickler_fields(2)%y(msh%nseg))
!             allocate(msh%strickler_fields(3)%x(msh%nseg))
!             allocate(msh%strickler_fields(3)%y(msh%nseg))
!             msh%strickler_fields(1)%interp = "linear"
!             msh%strickler_fields(1)%y(:) = strickler_params(1, :)
!             msh%strickler_fields(2)%interp = "linear"
!             msh%strickler_fields(2)%y(:) = strickler_params(2, :)
!             msh%strickler_fields(3)%interp = "linear"
!             msh%strickler_fields(3)%y(:) = strickler_params(3, :)
#endif
#ifdef AVERAGE_CONVEYANCE
        else if (msh%strickler_type_code == strickler_type_average_conveyance) then
            ! TODO
            call abort_solver("Not implemented for 'average_conveyance' model")
!             allocate(msh%strickler_fields(3))
!             allocate(msh%strickler_fields(1)%x(msh%nseg))
!             allocate(msh%strickler_fields(1)%y(msh%nseg))
!             allocate(msh%strickler_fields(2)%x(msh%nseg))
!             allocate(msh%strickler_fields(2)%y(msh%nseg))
!             allocate(msh%strickler_fields(3)%x(msh%nseg))
!             allocate(msh%strickler_fields(3)%y(msh%nseg))
!             msh%strickler_fields(1)%interp = "linear"
!             msh%strickler_fields(1)%y(:) = strickler_params(1, :)
!             msh%strickler_fields(2)%interp = "linear"
!             msh%strickler_fields(2)%y(:) = strickler_params(2, :)
!             msh%strickler_fields(3)%interp = "linear"
!             msh%strickler_fields(3)%y(:) = strickler_params(3, :)
#endif
#ifdef DEBORD_FORMULA
        else if (msh%strickler_type_code == strickler_type_debord) then
            ! TODO
            call abort_solver("Not implemented for Debord formula")
#endif
        end if
        call apply_strickler_fields(msh)
    end subroutine


    subroutine get_segment_curvilinear_abscissae(msh, iseg, x)
        implicit none
        type(Mesh), intent(inout) :: msh
        integer(ip), intent(in) :: iseg
        real(rp), dimension(:), allocatable, intent(out) :: x
        
        ! Iterator
        integer(ip) :: i
        ! Index of cross-section
        integer(ip) :: ics
        
        
        ! TODO check sizes
        allocate(x(10))
        x(:) = 1.0
        
    end subroutine


    !> @return global index (0-based) of segment's cross-section 
    subroutine get_segment_cs_index(msh, iseg, ics_seg, ics)
        implicit none
        type(Mesh), intent(inout) :: msh
        integer(ip), intent(in) :: iseg
        integer(ip), intent(in) :: ics_seg
        integer(ip), intent(out) :: ics
        
        
        ics = msh%seg(iseg+1)%first_cs + ics_seg - 1
        
    end subroutine


    subroutine update_bathy_slopes(msh)
        implicit none
        type(Mesh), intent(inout) :: msh
        
        call bathy_slopes(msh)
    
    end subroutine


    subroutine summary(msh)
        implicit none
        type(Mesh), intent(in) :: msh
        
        ! Iterator
        integer(ip) :: i
        ! Number of boundary conditions
        integer(ip) :: nbc
        ! Temporary string
        character(len=32) :: tmp
        
        write(tmp, '(I32)') msh%ncs
        write(*, '(2A)') "MESH:number of cross-sections: ", trim(adjustl(tmp))
        write(tmp, '(I32)') size(msh%seg)
        write(*, '(2A)') "     number of segments: ", trim(adjustl(tmp))
        do i = 1, size(msh%seg)
            if (msh%seg(i)%ds_bc > 0) then
                write(tmp, '(F32.6)') msh%cs(msh%seg(i)%last_cs)%slope * 1000.0
                write(*, '(3A)') "     downstream_slope: ", trim(adjustl(tmp)), "m/km"
            end if
        end do
        
    end subroutine
        
#endif

end module m_mesh
